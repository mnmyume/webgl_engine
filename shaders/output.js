var basicVert = {"code":"\n#line 1 1 \n  uniform mat4 _uni_projMat;\r \n#line 2 1 \n  uniform mat4 _uni_viewMat;\r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform mat4 _uni_modelMat;\r \n#line 5 1 \n  \r \n#line 6 1 \n  \r \n#line 7 1 \n  attribute vec3 aVertex;\r \n#line 8 1 \n  \r \n#line 9 1 \n  \r \n#line 10 1 \n  attribute vec2 aUV;\r \n#line 11 1 \n  \r \n#line 12 1 \n  varying vec2 vUV;\r \n#line 13 1 \n  \r \n#line 14 1 \n  void main(void) {\r \n#line 15 1 \n  \r \n#line 16 1 \n      vec3 position = aVertex;\r \n#line 17 1 \n  \r \n#line 18 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position, 1.0);\r \n#line 19 1 \n      vUV = aUV;\r \n#line 20 1 \n  }\r \n#line 21 1 \n   \n","extension":{},"attribute":{"aVertex":{"type":"vec3","value":{"size":"3","stride":"20","offset":"0"},"name":"quadBuffer"},"aUV":{"type":"vec2","value":{"size":"2","stride":"20","offset":"12"},"name":"quadBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}},"file":{"1":"./shaders/glsl/basic-vert.glsl"}};

var basicFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform vec3 uColor;\r \n#line 5 1 \n  \r \n#line 6 1 \n  varying vec2 vUV;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform sampler2D uTex;\r \n#line 9 1 \n  \r \n#line 10 1 \n  void main(void) {\r \n#line 11 1 \n  \r \n#line 12 1 \n     gl_FragColor =   // vec4(uColor, 1.0);\r \n#line 13 1 \n          vec4(texture2D(uTex,vUV).rgb, 1.0);\r \n#line 14 1 \n  }\r \n#line 15 1 \n   \n","extension":{},"attribute":{},"uniform":{"uColor":{"type":"vec3","value":[0,1,0]},"uTex":{"type":"sampler2D","value":0}},"file":{"1":"./shaders/glsl/basic-frag.glsl"}};

var particle3dVert = {"code":"\n#line 1 1 \n  uniform float duration;\r \n#line 2 1 \n  uniform float time;\r \n#line 3 1 \n  uniform float frameDuration;\r \n#line 4 1 \n  uniform float numFrames;\r \n#line 5 1 \n  uniform mat4 _uni_projMat;\r \n#line 6 1 \n  uniform mat4 _uni_viewMat;\r \n#line 7 1 \n  uniform mat4 _uni_modelMat;\r \n#line 8 1 \n  \r \n#line 9 1 \n  // Incoming vertex attributes\r \n#line 10 1 \n  attribute vec4 uvLifeTimeFrameStart; // uv, lifeTime, frameStart\r \n#line 11 1 \n  attribute vec4 positionStartTime;    // position.xyz, startTime\r \n#line 12 1 \n  attribute vec4 velocityStartSize;    // velocity.xyz, startSize\r \n#line 13 1 \n  attribute vec4 accelerationEndSize;  // acceleration.xyz, endSize\r \n#line 14 1 \n  attribute vec4 spinStartSpinSpeed;   // spinStart.x, spinSpeed.y\r \n#line 15 1 \n  attribute vec4 orientation;          // orientation quaternion\r \n#line 16 1 \n  attribute vec4 colorMult;            // multiplies color and ramp textures\r \n#line 17 1 \n  \r \n#line 18 1 \n  // Outgoing variables to fragment shader\r \n#line 19 1 \n  varying vec2 outputTexcoord;\r \n#line 20 1 \n  varying float outputPercentLife;\r \n#line 21 1 \n  varying vec4 outputColorMult;\r \n#line 22 1 \n  \r \n#line 23 1 \n  void main(void) {\r \n#line 24 1 \n      vec2 uv = uvLifeTimeFrameStart.xy;\r \n#line 25 1 \n      float lifeTime = uvLifeTimeFrameStart.z;\r \n#line 26 1 \n      float frameStart = uvLifeTimeFrameStart.w;\r \n#line 27 1 \n      vec3 position = positionStartTime.xyz;\r \n#line 28 1 \n      float startTime = positionStartTime.w;\r \n#line 29 1 \n      vec3 velocity = velocityStartSize.xyz;\r \n#line 30 1 \n      float startSize = velocityStartSize.w;\r \n#line 31 1 \n      vec3 acceleration = accelerationEndSize.xyz;\r \n#line 32 1 \n      float endSize = accelerationEndSize.w;\r \n#line 33 1 \n      float spinStart = spinStartSpinSpeed.x;\r \n#line 34 1 \n      float spinSpeed = spinStartSpinSpeed.y;\r \n#line 35 1 \n      \r \n#line 36 1 \n      float localTime = mod((time - startTime), duration);\r \n#line 37 1 \n      float percentLife = localTime / lifeTime;\r \n#line 38 1 \n      float frame = mod(floor(localTime / frameDuration + frameStart),\r \n#line 39 1 \n                  numFrames);\r \n#line 40 1 \n      float uOffset = frame / numFrames;\r \n#line 41 1 \n      float u = uOffset + (uv.x + 0.5) * (1. / numFrames);\r \n#line 42 1 \n  \r \n#line 43 1 \n      outputTexcoord = vec2(u, uv.y + 0.5);\r \n#line 44 1 \n      outputColorMult = colorMult;\r \n#line 45 1 \n      \r \n#line 46 1 \n      float size = mix(startSize, endSize, percentLife);\r \n#line 47 1 \n      size = (percentLife < 0. || percentLife > 1.) ? 0. : size;\r \n#line 48 1 \n      float s = sin(spinStart + spinSpeed * localTime);\r \n#line 49 1 \n      float c = cos(spinStart + spinSpeed * localTime);\r \n#line 50 1 \n      vec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0., \r \n#line 51 1 \n                               (uv.x * s - uv.y * c) * size, 1.);\r \n#line 52 1 \n      vec3 center = velocity * localTime +\r \n#line 53 1 \n                    acceleration * localTime * localTime + \r \n#line 54 1 \n                    position;\r \n#line 55 1 \n      vec4 q2 = orientation + orientation;\r \n#line 56 1 \n      vec4 qx = orientation.xxxw * q2.xyzx;\r \n#line 57 1 \n      vec4 qy = orientation.xyyw * q2.xyzy;\r \n#line 58 1 \n      vec4 qz = orientation.xxzw * q2.xxzz;\r \n#line 59 1 \n      mat4 localMatrix = mat4(\r \n#line 60 1 \n          (1.0 - qy.y) - qz.z, \r \n#line 61 1 \n          qx.y + qz.w, \r \n#line 62 1 \n          qx.z - qy.w,\r \n#line 63 1 \n          0,\r \n#line 64 1 \n          qx.y - qz.w, \r \n#line 65 1 \n          (1.0 - qx.x) - qz.z, \r \n#line 66 1 \n          qy.z + qx.w,\r \n#line 67 1 \n          0,\r \n#line 68 1 \n          qx.z + qy.w, \r \n#line 69 1 \n          qy.z - qx.w, \r \n#line 70 1 \n          (1.0 - qx.x) - qy.y,\r \n#line 71 1 \n          0,\r \n#line 72 1 \n          center.x, center.y, center.z, 1);\r \n#line 73 1 \n  \r \n#line 74 1 \n      rotatedPoint = localMatrix * rotatedPoint;\r \n#line 75 1 \n  \r \n#line 76 1 \n      outputPercentLife = percentLife;\r \n#line 77 1 \n  \r \n#line 78 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * rotatedPoint;\r \n#line 79 1 \n  } \n","extension":{},"attribute":{"uvLifeTimeFrameStart":{"type":"vec4","value":null},"positionStartTime":{"type":"vec4","value":null},"velocityStartSize":{"type":"vec4","value":null},"accelerationEndSize":{"type":"vec4","value":null},"spinStartSpinSpeed":{"type":"vec4","value":null},"orientation":{"type":"vec4","value":null},"colorMult":{"type":"vec4","value":null}},"uniform":{"duration":{"type":"float","value":null},"time":{"type":"float","value":null},"frameDuration":{"type":"float","value":null},"numFrames":{"type":"float","value":null},"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":null}},"file":{"1":"./shaders/glsl/particle3d-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var particle2dVert = {"code":"uniform vec4 _ANI_TEX_0;  // texWidth.x, texHeight.y, tileSize.z, numFrames.w\r\nuniform float _ANI_TEX_0_FPS;    // frameDuration = numFrames / _ANI_TEX_0_FPS;\r\nvarying vec4 _ANI_TEX_UV; // ux.xy, numCols.z, numRows.w\r\n\r\nvoid _GEN_ANI_TEX_UV(float texWidth, float texHeight, float tileSize, float frame){\r\n  float numCols = texWidth / tileSize;\r\n  float numRows = texHeight / tileSize;\r\n  float row = floor(frame / numCols);\r\n  float col = mod(frame, numCols);\r\n  float uOffset = col / numCols;\r\n  float vOffset = row / numRows;\r\n\r\n  _ANI_TEX_UV = vec4(\r\n      uOffset, // + (uv.x + 0.5) / numCols\r\n      vOffset, //  - (uv.y + 0.5) / numRows\r\n      numCols, \r\n      numRows\r\n  );\r\n}\n#line 1 2 \n  \r \n#line 2 2 \n  \r \n#line 3 2 \n  //https://registry.khronos.org/OpenGL/extensions/OES/OES_texture_float.txt\r \n#line 4 2 \n  \r \n#line 5 2 \n  \r \n#line 6 2 \n  // uniform\r \n#line 7 2 \n  uniform mat4 _uni_projMat;\r \n#line 8 2 \n  uniform mat4 _uni_viewMat;\r \n#line 9 2 \n  uniform mat4 _uni_modelMat;\r \n#line 10 2 \n  uniform float uDuration;\r \n#line 11 2 \n  uniform float uTime;\r \n#line 12 2 \n  uniform float uPartiCount;\r \n#line 13 2 \n  uniform float uNumGen;\r \n#line 14 2 \n  uniform vec3 uGravity;\r \n#line 15 2 \n  uniform float uLifeTime;\r \n#line 16 2 \n  \r \n#line 17 2 \n  \r \n#line 18 2 \n  // PixelOne(pos.xyz, startSize.w) PixelTwo(linearVel.xyz, endSize.w)\r \n#line 19 2 \n  \r \n#line 20 2 \n  uniform sampler2D uGeneratorSampler;\r \n#line 21 2 \n  \r \n#line 22 2 \n  \r \n#line 23 2 \n  #define ANI_TEX\r \n#line 24 2 \n  /* MACRO */\r \n#line 25 2 \n  #ifdef ANI_TEX\r \n#line 26 2 \n  #endif  /* MACRO ANI_TEX*/\r \n#line 27 2 \n  \r \n#line 28 2 \n  // attribute\r \n#line 29 2 \n  attribute float aStartTime;\r \n#line 30 2 \n  attribute float aParticleID;\r \n#line 31 2 \n  \r \n#line 32 2 \n  varying float vPercentLife;\r \n#line 33 2 \n  \r \n#line 34 2 \n  const float NUM_COMPONENTS = 2.0;\r \n#line 35 2 \n  float pidPixels(float pid){\r \n#line 36 2 \n    return  pid*NUM_COMPONENTS;\r \n#line 37 2 \n  }\r \n#line 38 2 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 39 2 \n    return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 40 2 \n  }\r \n#line 41 2 \n  \r \n#line 42 2 \n  void main() {\r \n#line 43 2 \n    \r \n#line 44 2 \n    // aniTex\r \n#line 45 2 \n    float texWidth = _ANI_TEX_0.x;\r \n#line 46 2 \n    float texHeight = _ANI_TEX_0.y;\r \n#line 47 2 \n    float tileSize = _ANI_TEX_0.z;\r \n#line 48 2 \n    float numFrames = _ANI_TEX_0.w;\r \n#line 49 2 \n    float frameDuration = 1.0 / _ANI_TEX_0_FPS;\r \n#line 50 2 \n  \r \n#line 51 2 \n    float localTime = mod(uTime - aStartTime, uLifeTime) ;\r \n#line 52 2 \n    float percentLife = localTime / uLifeTime;\r \n#line 53 2 \n    float frame = mod(floor(localTime / frameDuration), numFrames);\r \n#line 54 2 \n    float generation = floor((uTime - aStartTime) / uDuration);\r \n#line 55 2 \n  \r \n#line 56 2 \n    float componentOffset = 0.0;\r \n#line 57 2 \n    float posTexCoordU = pidPixelsOffset(aParticleID, componentOffset) / pidPixels(uPartiCount);\r \n#line 58 2 \n    float posTexCoordV = 1.0 - (generation / uNumGen + 0.5 / uNumGen);  \r \n#line 59 2 \n    vec2 posTexCoord = vec2(posTexCoordU, posTexCoordV);\r \n#line 60 2 \n    vec3 position = texture2D(uGeneratorSampler, posTexCoord).xyz;\r \n#line 61 2 \n    float startSize = texture2D(uGeneratorSampler, posTexCoord).w;\r \n#line 62 2 \n  \r \n#line 63 2 \n    componentOffset = 1.0;\r \n#line 64 2 \n    float linearVelTexCoordU =  pidPixelsOffset(aParticleID, componentOffset) / pidPixels(uPartiCount);\r \n#line 65 2 \n    float linearVelTexCoordV = 1.0 - (generation / uNumGen + 0.5 / uNumGen);  \r \n#line 66 2 \n    vec2 linearVelTexCoord = vec2(linearVelTexCoordU, linearVelTexCoordV);\r \n#line 67 2 \n    vec3 linearVelocity = texture2D(uGeneratorSampler, linearVelTexCoord).xyz;\r \n#line 68 2 \n    float endSize = texture2D(uGeneratorSampler, linearVelTexCoord).w;\r \n#line 69 2 \n  \r \n#line 70 2 \n    _GEN_ANI_TEX_UV(texWidth, texHeight, tileSize, frame);\r \n#line 71 2 \n  \r \n#line 72 2 \n    float size = mix(startSize, endSize, percentLife);\r \n#line 73 2 \n    size = (percentLife < 0. || percentLife > 1.) ? 0. : size;\r \n#line 74 2 \n  \r \n#line 75 2 \n    vec3 velocity = linearVelocity;\r \n#line 76 2 \n    vec3 localPosition = velocity * localTime +\r \n#line 77 2 \n                         // acceleration * localTime * localTime + \r \n#line 78 2 \n                         position; \r \n#line 79 2 \n                         \r \n#line 80 2 \n    vPercentLife = percentLife;\r \n#line 81 2 \n    gl_PointSize = size; \r \n#line 82 2 \n    gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(localPosition, 1.);\r \n#line 83 2 \n  }\r \n#line 84 2 \n   \n","extension":{"GL_OES_texture_float":"enable","GL_OES_texture_float_linear":"enable"},"attribute":{"aStartTime":{"type":"float","value":null},"aParticleID":{"type":"float","value":null}},"uniform":{"_ANI_TEX_0":{"type":"vec4","value":null},"_ANI_TEX_0_FPS":{"type":"float","value":null},"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":null},"uDuration":{"type":"float","value":null},"uTime":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uNumGen":{"type":"float","value":null},"uGravity":{"type":"vec3","value":null},"uLifeTime":{"type":"float","value":null},"uGeneratorSampler":{"type":"sampler2D","value":2}},"file":{"1":"./shaders/glsl/basic-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var particleFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D uRampSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  \r \n#line 7 1 \n  uniform sampler2D uColorSampler;\r \n#line 8 1 \n  \r \n#line 9 1 \n  // Incoming variables from vertex shader\r \n#line 10 1 \n  varying float vPercentLife;\r \n#line 11 1 \n  varying vec4 _ANI_TEX_UV;   // ux.xy, numCols.z, numRows.w\r \n#line 12 1 \n  \r \n#line 13 1 \n  void main(void) {\r \n#line 14 1 \n      vec2 pointUV = vec2(_ANI_TEX_UV.x, _ANI_TEX_UV.y);\r \n#line 15 1 \n      float numCols = _ANI_TEX_UV.z;\r \n#line 16 1 \n      float numRows = _ANI_TEX_UV.w;\r \n#line 17 1 \n      vec2 pointCoord = pointUV + vec2(gl_PointCoord.x / numCols, gl_PointCoord.y / numRows);\r \n#line 18 1 \n      vec4 colorMult = texture2D(uRampSampler, vec2(vPercentLife, 0.5));\r \n#line 19 1 \n      gl_FragColor = texture2D(uColorSampler, pointCoord);    // * colorMult;\r \n#line 20 1 \n      // gl_FragColor = colorMult;\r \n#line 21 1 \n  } \n","extension":{},"attribute":{},"uniform":{"uRampSampler":{"type":"sampler2D","value":0},"uColorSampler":{"type":"sampler2D","value":1}},"file":{"1":"./shaders/glsl/particle-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var screenQuadVert = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  attribute vec2 aQuad;\r \n#line 7 1 \n  \r \n#line 8 1 \n  void main() {\r \n#line 9 1 \n      gl_Position = vec4(aQuad, 0.0, 1.0);\r \n#line 10 1 \n  }\r \n#line 11 1 \n   \n","extension":{},"attribute":{"aQuad":{"type":"vec2","value":{"size":"2","stride":"8","offset":"0"},"name":"quadBuffer"}},"uniform":{},"file":{"1":"./shaders/glsl/screenQuad-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var screenQuadFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  uniform vec2 uCanvas;\r \n#line 4 1 \n  \r \n#line 5 1 \n  void main(void) {\r \n#line 6 1 \n  \r \n#line 7 1 \n      vec2 uv = gl_FragCoord.xy;\r \n#line 8 1 \n  \r \n#line 9 1 \n      float gradient = (1.0 - uv.y / uCanvas.x)*0.4;    // iResolution.x\r \n#line 10 1 \n  \r \n#line 11 1 \n      vec3 color = gradient * vec3(0.4,0.8,1.0);\r \n#line 12 1 \n  \r \n#line 13 1 \n      gl_FragColor = vec4(color, 1.0);\r \n#line 14 1 \n  }\r \n#line 15 1 \n   \n","extension":{},"attribute":{},"uniform":{"uCanvas":{"type":"vec2","value":null}},"file":{"1":"./shaders/glsl/screenQuad-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var solverFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  \r \n#line 5 1 \n  #define GEN_SIZE 2\r \n#line 6 1 \n  \r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform sampler2D uEmitterSlot0[GEN_SIZE];      // posX, posZ, size, startTime\r \n#line 9 1 \n  \r \n#line 10 1 \n  uniform sampler2D uEmitterSlot1[GEN_SIZE];      // linVelX, linVelY, linVelZ, _empty\r \n#line 11 1 \n  \r \n#line 12 1 \n  uniform sampler2D uEmitterSlot2[GEN_SIZE];      // angVelX, angVelZ, _empty, _empty\r \n#line 13 1 \n  \r \n#line 14 1 \n  //\r \n#line 15 1 \n  //\r \n#line 16 1 \n  //\r \n#line 17 1 \n  //\r \n#line 18 1 \n  //uniform vec4 test[GEN_SIZE];      // posX, posZ, size, startTime\r \n#line 19 1 \n  \r \n#line 20 1 \n  \r \n#line 21 1 \n  uniform sampler2D uDataSlot0;    // posX, posY, posZ, size\r \n#line 22 1 \n  \r \n#line 23 1 \n  uniform sampler2D uDataSlot1;    // velX, velY, velZ, generation\r \n#line 24 1 \n  \r \n#line 25 1 \n  uniform sampler2D uDataSlot2;    // rotX, rotZ, percentLife, ____\r \n#line 26 1 \n  \r \n#line 27 1 \n  uniform sampler2D uDataSlot3;    // colorX, colorY, colorZ, ____\r \n#line 28 1 \n  \r \n#line 29 1 \n  \r \n#line 30 1 \n  uniform float uDeltaTime;\r \n#line 31 1 \n  \r \n#line 32 1 \n  \r \n#line 33 1 \n  uniform mat4 uEmitterTransform;\r \n#line 34 1 \n  \r \n#line 35 1 \n   \r \n#line 36 1 \n  uniform int uState;  // init mode, uState = 1; play mode, uState = 2;\r \n#line 37 1 \n  // \r \n#line 38 1 \n  uniform bool uLoop;\r \n#line 39 1 \n  \r \n#line 40 1 \n  uniform float uTime;         //gameTime\r \n#line 41 1 \n  \r \n#line 42 1 \n  // \r \n#line 43 1 \n  uniform float uDuration; // -1 infinite\r \n#line 44 1 \n  uniform float uGeneCount;\r \n#line 45 1 \n  uniform float uLifeTime;\r \n#line 46 1 \n  uniform float uPartiCount;\r \n#line 47 1 \n  uniform float uMAXCOL;\r \n#line 48 1 \n  \r \n#line 49 1 \n  uniform vec4 uGrid;  // width.r, height.g, corner.ba\r \n#line 50 1 \n  uniform vec2 uWorldSize;\r \n#line 51 1 \n  uniform vec2 uResolution;\r \n#line 52 1 \n  \r \n#line 53 1 \n  #define PARMS 4\r \n#line 54 1 \n  \r \n#line 55 1 \n                                                          // 1: switcher.x, vortexScalar.y, __, __;\r \n#line 56 1 \n  uniform vec4 uFieldParams[PARMS];                        // 2: switcher.x, noiseScalar.yzw;\r \n#line 57 1 \n                                                          // 3: switcher.x, dampScalar.y, __, __;\r \n#line 58 1 \n  \r \n#line 59 1 \n  float dot2(vec2 a, vec2 b) {\r \n#line 60 1 \n      return a.x * b.x + a.y * b.y;\r \n#line 61 1 \n  }\r \n#line 62 1 \n  \r \n#line 63 1 \n  float halton(int base, int index) {\r \n#line 64 1 \n      float result = 0.0;\r \n#line 65 1 \n      float digitWeight = 1.0;\r \n#line 66 1 \n      digitWeight = digitWeight / float(base); \r \n#line 67 1 \n      int nominator;\r \n#line 68 1 \n      for (int i = 0; i < 10; i++) {\r \n#line 69 1 \n          nominator = index - (index / base) * base;  // int mod\r \n#line 70 1 \n          result += float(nominator) * digitWeight;\r \n#line 71 1 \n          index = index / base;\r \n#line 72 1 \n          digitWeight = digitWeight / float(base);\r \n#line 73 1 \n          if (index == 0) {\r \n#line 74 1 \n              break;\r \n#line 75 1 \n          }\r \n#line 76 1 \n      }\r \n#line 77 1 \n      return result;\r \n#line 78 1 \n  }\r \n#line 79 1 \n  \r \n#line 80 1 \n  vec3 gravityField(vec3 linVel, vec3 gravity) {\r \n#line 81 1 \n      linVel = linVel + gravity * uDeltaTime;\r \n#line 82 1 \n      return linVel;\r \n#line 83 1 \n  }\r \n#line 84 1 \n  \r \n#line 85 1 \n  vec3 vortexField(vec3 pos, float scalar){   //vec3 axis, needs Quaternion Helper\r \n#line 86 1 \n      vec3 linVel = vec3(-pos.z,0, pos.x)*scalar;\r \n#line 87 1 \n      return linVel;\r \n#line 88 1 \n  }\r \n#line 89 1 \n  \r \n#line 90 1 \n  vec3 noiseField(vec3 pos, vec3 scalar) {\r \n#line 91 1 \n  \r \n#line 92 1 \n      float x = fract(sin(dot2(pos.xy,vec2(12.9898,78.233)))* 43758.5453)-0.5;\r \n#line 93 1 \n      float y = fract(sin(dot2(pos.xy,vec2(62.2364,94.674)))* 62159.8432)-0.5;\r \n#line 94 1 \n      float z = fract(sin(dot2(pos.xy,vec2(989.2364,94.674)))* 12349.8432)-0.5;\r \n#line 95 1 \n  \r \n#line 96 1 \n      vec3 d = vec3(x,y,z);\r \n#line 97 1 \n  \r \n#line 98 1 \n      return scalar*normalize(d);\r \n#line 99 1 \n  }\r \n#line 100 1 \n  \r \n#line 101 1 \n  vec3 damp(vec3 linVel, float k, float dTime){\r \n#line 102 1 \n      return linVel*(1.0-k);\r \n#line 103 1 \n  }\r \n#line 104 1 \n  \r \n#line 105 1 \n  void updatePosVel(inout vec3 pos, inout vec3 linVel) { // vec2 obs, vec2 index\r \n#line 106 1 \n      pos = pos + linVel * uDeltaTime;\r \n#line 107 1 \n      \r \n#line 108 1 \n  //    // reset pos if particle out boundary\r \n#line 109 1 \n  //     float width = uWorldSize.x / 2.0;\r \n#line 110 1 \n  //     float height = uWorldSize.y / 2.0;\r \n#line 111 1 \n  //     int n = int(index.x+1.0 + index.y*uResolution.x);\r \n#line 112 1 \n  //     vec2 random = vec2(halton(2, n), halton(3, n));\r \n#line 113 1 \n  //     if(abs(pos.x) > width || abs(pos.y) > height){\r \n#line 114 1 \n  //         pos.y = uGrid.g;\r \n#line 115 1 \n  //         pos.z = uGrid.a + uGrid.r * random.y;\r \n#line 116 1 \n  //         pos.x = uGrid.b + uGrid.r * random.x;\r \n#line 117 1 \n  //         linVel.x = 0.0;\r \n#line 118 1 \n  //         linVel.y = 0.0;\r \n#line 119 1 \n  //     }\r \n#line 120 1 \n  //\r \n#line 121 1 \n  //    // obstacle\r \n#line 122 1 \n  //    if (obs.y > 0.0) {\r \n#line 123 1 \n  //        pos.xy = pos.xy - linVel.xy * uDeltaTime;\r \n#line 124 1 \n  //        pos.xy = pos.xy + obs;\r \n#line 125 1 \n  //        if (length(linVel) < 0.5) {\r \n#line 126 1 \n  //            linVel.xy = obs * 0.5; // velocity too low, jiggle outward\r \n#line 127 1 \n  //        } else {\r \n#line 128 1 \n  //            linVel.xy = reflect(linVel.xy, obs) * 0.25; // bounce, restitution\r \n#line 129 1 \n  //        }\r \n#line 130 1 \n  //    }\r \n#line 131 1 \n  }\r \n#line 132 1 \n  \r \n#line 133 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 134 1 \n  float pidPixels(float pid){\r \n#line 135 1 \n    return  pid*NUM_COMPONENTS;\r \n#line 136 1 \n  }\r \n#line 137 1 \n  \r \n#line 138 1 \n  //vec2 getEmitterCoord(float pid, float generation, float uPartiCount, float uGeneCount){\r \n#line 139 1 \n  //    return vec2(pid/uPartiCount+0.5, generation/uGeneCount+0.5);\r \n#line 140 1 \n  //}\r \n#line 141 1 \n  vec2 getEmitterCoord(float pid, float uMAXCOL){\r \n#line 142 1 \n      vec2 uv = vec2(mod(pid,uMAXCOL), floor(pid/uMAXCOL))/uMAXCOL;\r \n#line 143 1 \n      uv += vec2(1.0/uMAXCOL*0.5);    //  offset to center of pixel\r \n#line 144 1 \n      return uv;\r \n#line 145 1 \n  }\r \n#line 146 1 \n  \r \n#line 147 1 \n  //https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml\r \n#line 148 1 \n  // lower-left origin\r \n#line 149 1 \n  float getPID(vec2 fragCoord, float uMAXCOL){\r \n#line 150 1 \n      return (uMAXCOL-1.0-floor(fragCoord.y)) * uMAXCOL + floor(fragCoord.x);\r \n#line 151 1 \n  }\r \n#line 152 1 \n  \r \n#line 153 1 \n  void main() {\r \n#line 154 1 \n      vec2 uv = gl_FragCoord.xy / uResolution;\r \n#line 155 1 \n  \r \n#line 156 1 \n      float particleID = getPID(gl_FragCoord.xy, uMAXCOL);\r \n#line 157 1 \n  \r \n#line 158 1 \n      vec3 pos, linVel;\r \n#line 159 1 \n      vec2 angVel;\r \n#line 160 1 \n      float size;\r \n#line 161 1 \n  \r \n#line 162 1 \n      vec2 emitterUV = getEmitterCoord(particleID, uMAXCOL);\r \n#line 163 1 \n      float startTime = texture2D(uEmitterSlot0[0], emitterUV).w;\r \n#line 164 1 \n      vec3 partiCol = vec3(1.0, 1.0, 1.0);\r \n#line 165 1 \n      float localTime = uTime - startTime > 0.0 ? mod(uTime - startTime, uLifeTime) : 0.0;\r \n#line 166 1 \n      float percentLife = localTime / uLifeTime;\r \n#line 167 1 \n  \r \n#line 168 1 \n      int lastGene = int(texture2D(uDataSlot1, uv).w);\r \n#line 169 1 \n      int generation = uTime - startTime > 0.0 ? int(mod(floor((uTime - startTime)/uLifeTime), float(GEN_SIZE))) : -1;\r \n#line 170 1 \n  \r \n#line 171 1 \n  \r \n#line 172 1 \n      bool emit = generation != lastGene ;\r \n#line 173 1 \n      if(emit || uState == 1){\r \n#line 174 1 \n          vec2 emitterPos = vec2(0,0);\r \n#line 175 1 \n  \r \n#line 176 1 \n          if(generation == 0){\r \n#line 177 1 \n              size = texture2D(uEmitterSlot0[0], emitterUV).z;\r \n#line 178 1 \n              emitterPos = texture2D(uEmitterSlot0[0], emitterUV).xy;\r \n#line 179 1 \n              linVel = texture2D(uEmitterSlot1[0], emitterUV).xyz;\r \n#line 180 1 \n          }else if(generation == 1){\r \n#line 181 1 \n              size = texture2D(uEmitterSlot0[1], emitterUV).z;\r \n#line 182 1 \n              emitterPos = texture2D(uEmitterSlot0[1], emitterUV).xy;\r \n#line 183 1 \n              linVel = texture2D(uEmitterSlot1[1], emitterUV).xyz;\r \n#line 184 1 \n          }\r \n#line 185 1 \n  //        else if(generation == 2)\r \n#line 186 1 \n  //            emitterPos = texture2D(uEmitterSlot0[2], emitterUV).xy;\r \n#line 187 1 \n  //        else if(generation == 3)\r \n#line 188 1 \n  //            emitterPos = texture2D(uEmitterSlot0[3], emitterUV).xy;\r \n#line 189 1 \n  \r \n#line 190 1 \n          pos = (uEmitterTransform * vec4(emitterPos.x, 0, emitterPos.y, 1)).xyz;\r \n#line 191 1 \n          linVel = vec3(0);\r \n#line 192 1 \n      }\r \n#line 193 1 \n  \r \n#line 194 1 \n      ////////////////////////////INTEGRATION-----UPDATE\r \n#line 195 1 \n      else{\r \n#line 196 1 \n  \r \n#line 197 1 \n          pos = texture2D(uDataSlot0, uv).xyz;\r \n#line 198 1 \n          vec3 oldVel = texture2D(uDataSlot1, uv).xyz;\r \n#line 199 1 \n          size = texture2D(uEmitterSlot0[0], emitterUV).z;\r \n#line 200 1 \n  \r \n#line 201 1 \n          float gravitySwitcher = uFieldParams[0].x;\r \n#line 202 1 \n          vec3 gravity = uFieldParams[0].yzw;\r \n#line 203 1 \n          float vortexSwitcher = uFieldParams[1].x;\r \n#line 204 1 \n          float vortexScalar = uFieldParams[1].y;\r \n#line 205 1 \n          float noiseSwitcher = uFieldParams[2].x;\r \n#line 206 1 \n          vec3 noiseScalar = uFieldParams[2].yzw;\r \n#line 207 1 \n          float dampSwitcher = uFieldParams[3].x;\r \n#line 208 1 \n          float dampScalar = uFieldParams[3].y;\r \n#line 209 1 \n  \r \n#line 210 1 \n          if(gravitySwitcher == 1.0) {\r \n#line 211 1 \n              linVel = gravityField(oldVel, gravity);\r \n#line 212 1 \n          }\r \n#line 213 1 \n          if(vortexSwitcher == 1.0) {\r \n#line 214 1 \n              linVel += vortexField(pos, vortexScalar);\r \n#line 215 1 \n          }\r \n#line 216 1 \n          if(noiseSwitcher == 1.0) {\r \n#line 217 1 \n              linVel  += noiseField(pos, noiseScalar);\r \n#line 218 1 \n          }\r \n#line 219 1 \n          if(dampSwitcher == 1.0){\r \n#line 220 1 \n              linVel = oldVel + damp(linVel-oldVel, dampScalar, uDeltaTime);\r \n#line 221 1 \n          }\r \n#line 222 1 \n  \r \n#line 223 1 \n          updatePosVel(pos, linVel);\r \n#line 224 1 \n  \r \n#line 225 1 \n      }\r \n#line 226 1 \n  \r \n#line 227 1 \n  \r \n#line 228 1 \n      gl_FragData[0] = vec4(pos, size);\r \n#line 229 1 \n      gl_FragData[1] = vec4(linVel, generation);\r \n#line 230 1 \n      gl_FragData[2] = vec4(angVel, percentLife, 1.0);\r \n#line 231 1 \n      gl_FragData[3] = vec4(partiCol, 1.0);\r \n#line 232 1 \n  \r \n#line 233 1 \n  }\r \n#line 234 1 \n   \n","extension":{"GL_EXT_draw_buffers":"require","GL_OES_texture_float":"enable"},"attribute":{},"uniform":{"uEmitterSlot0":{"type":"sampler2D[]","value":[0,1],"length":2},"uEmitterSlot1":{"type":"sampler2D[]","value":[2,3],"length":2},"uEmitterSlot2":{"type":"sampler2D[]","value":[4,5],"length":2},"uDataSlot0":{"type":"sampler2D","value":6},"uDataSlot1":{"type":"sampler2D","value":7},"uDataSlot2":{"type":"sampler2D","value":8},"uDataSlot3":{"type":"sampler2D","value":9},"uDeltaTime":{"type":"float","value":0.01666},"uEmitterTransform":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"uState":{"type":"int","value":0},"uLoop":{"type":"bool","value":null},"uTime":{"type":"float","value":null},"uDuration":{"type":"float","value":null},"uGeneCount":{"type":"float","value":null},"uLifeTime":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uMAXCOL":{"type":"float","value":null},"uGrid":{"type":"vec4","value":null},"uWorldSize":{"type":"vec2","value":null},"uResolution":{"type":"vec2","value":null},"uFieldParams":{"type":"vec4[]","value":[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0],"length":4}},"file":{"1":"./shaders/glsl/solver-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var solverPartiVert = {"code":"\n#line 1 1 \n  // uniform\r \n#line 2 1 \n  uniform mat4 _uni_projMat;\r \n#line 3 1 \n  uniform mat4 _uni_viewMat;\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform mat4 _uni_modelMat;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform float uGeneCount;\r \n#line 9 1 \n  uniform float uPartiCount;\r \n#line 10 1 \n  uniform float uMAXCOL;\r \n#line 11 1 \n  \r \n#line 12 1 \n  \r \n#line 13 1 \n  uniform sampler2D uDataSlot0;\r \n#line 14 1 \n  \r \n#line 15 1 \n  uniform sampler2D uDataSlot1;\r \n#line 16 1 \n  \r \n#line 17 1 \n  uniform sampler2D uDataSlot2;\r \n#line 18 1 \n  \r \n#line 19 1 \n  uniform sampler2D uDataSlot3;\r \n#line 20 1 \n  \r \n#line 21 1 \n  // attribute\r \n#line 22 1 \n  \r \n#line 23 1 \n  attribute float aParticleID;\r \n#line 24 1 \n  \r \n#line 25 1 \n  varying float vSize;\r \n#line 26 1 \n  varying vec3 vColor;\r \n#line 27 1 \n  \r \n#line 28 1 \n  varying float vDebug;\r \n#line 29 1 \n  \r \n#line 30 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 31 1 \n  float pidPixels(float pid){\r \n#line 32 1 \n    return  pid*NUM_COMPONENTS;\r \n#line 33 1 \n  }\r \n#line 34 1 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 35 1 \n    return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 36 1 \n  }\r \n#line 37 1 \n  \r \n#line 38 1 \n  vec2 getSolverCoord(float pid, float uMAXCOL){\r \n#line 39 1 \n    vec2 uv =  vec2(mod(pid,uMAXCOL), floor(pid/uMAXCOL)) / uMAXCOL;\r \n#line 40 1 \n    uv += vec2(1.0/uMAXCOL*0.5); //offset to center of pixel\r \n#line 41 1 \n    return uv;\r \n#line 42 1 \n  }\r \n#line 43 1 \n  \r \n#line 44 1 \n  void main() {\r \n#line 45 1 \n    // read position from texture\r \n#line 46 1 \n    vec2 solverCoord = getSolverCoord(aParticleID, uMAXCOL);\r \n#line 47 1 \n  \r \n#line 48 1 \n    vec3 position = texture2D(uDataSlot0, solverCoord).xyz;\r \n#line 49 1 \n    \r \n#line 50 1 \n    vSize = texture2D(uDataSlot0, solverCoord).w;\r \n#line 51 1 \n    vColor = texture2D(uDataSlot3, solverCoord).rgb;\r \n#line 52 1 \n  \r \n#line 53 1 \n    gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position,1);\r \n#line 54 1 \n    gl_PointSize = vSize;\r \n#line 55 1 \n  }\r \n#line 56 1 \n   \n","extension":{},"attribute":{"aParticleID":{"type":"float","value":{"size":"1","stride":"4","offset":"0"},"name":"partiBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"uGeneCount":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uMAXCOL":{"type":"float","value":null},"uDataSlot0":{"type":"sampler2D","value":0},"uDataSlot1":{"type":"sampler2D","value":1},"uDataSlot2":{"type":"sampler2D","value":2},"uDataSlot3":{"type":"sampler2D","value":3}},"file":{"1":"./shaders/glsl/solverParti-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var solverPartiFrag = {"code":"\n#line 1 1 \n  precision mediump float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D uColorSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  \r \n#line 7 1 \n  uniform float uBlurRadius;\r \n#line 8 1 \n  \r \n#line 9 1 \n  \r \n#line 10 1 \n  uniform float uRadius;\r \n#line 11 1 \n  \r \n#line 12 1 \n  \r \n#line 13 1 \n  uniform float uPixelNum;\r \n#line 14 1 \n  \r \n#line 15 1 \n  varying float vSize;\r \n#line 16 1 \n  varying vec3 vColor;\r \n#line 17 1 \n  varying float vDebug;\r \n#line 18 1 \n  \r \n#line 19 1 \n  void main() {\r \n#line 20 1 \n      // vec2 p = 2.0 * (gl_PointCoord - 0.5);\r \n#line 21 1 \n      float pixelNum = uPixelNum / 2.0;\r \n#line 22 1 \n      vec2 p = floor((2.0 * (gl_PointCoord - 0.5))*pixelNum)/pixelNum;\r \n#line 23 1 \n      float dist = length(p);\r \n#line 24 1 \n  \r \n#line 25 1 \n      if(vSize>1.0 && dist < uRadius) {\r \n#line 26 1 \n          float alpha = dist < uBlurRadius ? 1.0 : smoothstep(1.0, uBlurRadius, dist);\r \n#line 27 1 \n          gl_FragColor = vec4(vColor, alpha);\r \n#line 28 1 \n      } else {\r \n#line 29 1 \n          discard;\r \n#line 30 1 \n      }\r \n#line 31 1 \n  }\r \n#line 32 1 \n   \n","extension":{},"attribute":{},"uniform":{"uColorSampler":{"type":"sampler2D","value":1},"uBlurRadius":{"type":"float","value":0.1},"uRadius":{"type":"float","value":0.8},"uPixelNum":{"type":"float","value":8}},"file":{"1":"./shaders/glsl/solverParti-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var rainVert = {"code":"\n#line 1 1 \n  // uniform\r \n#line 2 1 \n  uniform mat4 _uni_projMat;\r \n#line 3 1 \n  uniform mat4 _uni_viewMat;\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform mat4 _uni_modelMat;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform float uGeneCount;\r \n#line 9 1 \n  uniform float uPartiCount;\r \n#line 10 1 \n  uniform float uMAXCOL;\r \n#line 11 1 \n  \r \n#line 12 1 \n  \r \n#line 13 1 \n  uniform sampler2D uDataSlot0;\r \n#line 14 1 \n  \r \n#line 15 1 \n  uniform sampler2D uDataSlot1;\r \n#line 16 1 \n  \r \n#line 17 1 \n  uniform sampler2D uDataSlot2;\r \n#line 18 1 \n  \r \n#line 19 1 \n  uniform sampler2D uDataSlot3;\r \n#line 20 1 \n  \r \n#line 21 1 \n  // attribute\r \n#line 22 1 \n  \r \n#line 23 1 \n  attribute float aParticleID;\r \n#line 24 1 \n  \r \n#line 25 1 \n  varying float vSize;\r \n#line 26 1 \n  varying vec3 vColor;\r \n#line 27 1 \n  varying vec3 vVel;\r \n#line 28 1 \n  \r \n#line 29 1 \n  varying float vDebug;\r \n#line 30 1 \n  \r \n#line 31 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 32 1 \n  float pidPixels(float pid){\r \n#line 33 1 \n      return  pid*NUM_COMPONENTS;\r \n#line 34 1 \n  }\r \n#line 35 1 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 36 1 \n      return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 37 1 \n  }\r \n#line 38 1 \n  \r \n#line 39 1 \n  vec2 getSolverCoord(float pid, float uMAXCOL){\r \n#line 40 1 \n      vec2 uv =  vec2(mod(pid,uMAXCOL), floor(pid/uMAXCOL)) / uMAXCOL;\r \n#line 41 1 \n      uv += vec2(1.0/uMAXCOL*0.5); //offset to center of pixel\r \n#line 42 1 \n      return uv;\r \n#line 43 1 \n  }\r \n#line 44 1 \n  \r \n#line 45 1 \n  void main() {\r \n#line 46 1 \n      // read position from texture\r \n#line 47 1 \n      vec2 solverCoord = getSolverCoord(aParticleID, uMAXCOL);\r \n#line 48 1 \n  \r \n#line 49 1 \n      //  vDebug = solverCoord.x;\r \n#line 50 1 \n  \r \n#line 51 1 \n      vec3 position = texture2D(uDataSlot0, solverCoord).xyz;\r \n#line 52 1 \n      vec3 velocity = texture2D(uDataSlot1, solverCoord).xyz;\r \n#line 53 1 \n  \r \n#line 54 1 \n      vSize = texture2D(uDataSlot0, solverCoord).w;\r \n#line 55 1 \n      vColor = texture2D(uDataSlot3, solverCoord).rgb;\r \n#line 56 1 \n      vVel = velocity;\r \n#line 57 1 \n  \r \n#line 58 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position,1);\r \n#line 59 1 \n      gl_PointSize = vSize;\r \n#line 60 1 \n  }\r \n#line 61 1 \n   \n","extension":{},"attribute":{"aParticleID":{"type":"float","value":{"size":"1","stride":"4","offset":"0"},"name":"partiBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"uGeneCount":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uMAXCOL":{"type":"float","value":null},"uDataSlot0":{"type":"sampler2D","value":0},"uDataSlot1":{"type":"sampler2D","value":1},"uDataSlot2":{"type":"sampler2D","value":2},"uDataSlot3":{"type":"sampler2D","value":3}},"file":{"1":"./shaders/glsl/rain-vert.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var rainFrag = {"code":"\n#line 1 1 \n  precision mediump float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D uColorSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform float uBlurRadius;\r \n#line 7 1 \n  uniform float uPixelNum;\r \n#line 8 1 \n  \r \n#line 9 1 \n  varying float vSize;\r \n#line 10 1 \n  varying vec3 vColor;\r \n#line 11 1 \n  varying vec3 vVel;\r \n#line 12 1 \n  \r \n#line 13 1 \n  varying float vDebug;\r \n#line 14 1 \n  \r \n#line 15 1 \n  float rainHeadSize = 0.16;\r \n#line 16 1 \n  \r \n#line 17 1 \n  void main() {\r \n#line 18 1 \n      vec2 uv = floor(vec2(gl_PointCoord.x, 1.-gl_PointCoord.y)*uPixelNum)/uPixelNum;\r \n#line 19 1 \n  \r \n#line 20 1 \n      vec3 rainDir = normalize(vVel);\r \n#line 21 1 \n  \r \n#line 22 1 \n      float rainLength = length(vVel);\r \n#line 23 1 \n      rainLength = clamp(rainLength, .0, .4);\r \n#line 24 1 \n      vec2 origin = vec2(0.5),\r \n#line 25 1 \n           halfSeg = rainLength * vec2(rainDir.xy),\r \n#line 26 1 \n           A = origin + halfSeg,\r \n#line 27 1 \n           B = origin - halfSeg;\r \n#line 28 1 \n  \r \n#line 29 1 \n  \r \n#line 30 1 \n      vec2 p = uv - A;\r \n#line 31 1 \n      B -= A;\r \n#line 32 1 \n  \r \n#line 33 1 \n      float t = clamp(dot(p, B) / dot(B, B), 0., 1.);\r \n#line 34 1 \n      float v = smoothstep(rainHeadSize*(1.-t), .0, length(p - B *t) );\r \n#line 35 1 \n      gl_FragColor = vec4(v,v,v,0.2);\r \n#line 36 1 \n  }\r \n#line 37 1 \n   \n","extension":{},"attribute":{},"uniform":{"uColorSampler":{"type":"sampler2D","value":1},"uBlurRadius":{"type":"float","value":null},"uPixelNum":{"type":"float","value":null}},"file":{"1":"./shaders/glsl/rain-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var arrowVert = {"code":"\n#line 1 1 \n  // uniform\r \n#line 2 1 \n  uniform mat4 _uni_projMat;\r \n#line 3 1 \n  uniform mat4 _uni_viewMat;\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform mat4 _uni_modelMat;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform float uGeneCount;\r \n#line 9 1 \n  uniform float uPartiCount;\r \n#line 10 1 \n  uniform float uMAXCOL;\r \n#line 11 1 \n  \r \n#line 12 1 \n  \r \n#line 13 1 \n  uniform sampler2D uDataSlot0;\r \n#line 14 1 \n  \r \n#line 15 1 \n  uniform sampler2D uDataSlot1;\r \n#line 16 1 \n  \r \n#line 17 1 \n  uniform sampler2D uDataSlot2;\r \n#line 18 1 \n  \r \n#line 19 1 \n  uniform sampler2D uDataSlot3;\r \n#line 20 1 \n  \r \n#line 21 1 \n  // attribute\r \n#line 22 1 \n  \r \n#line 23 1 \n  attribute float aParticleID;\r \n#line 24 1 \n  \r \n#line 25 1 \n  varying float vSize;\r \n#line 26 1 \n  varying vec3 vColor;\r \n#line 27 1 \n  varying vec3 vVel;\r \n#line 28 1 \n  \r \n#line 29 1 \n  varying float vDebug;\r \n#line 30 1 \n  \r \n#line 31 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 32 1 \n  float pidPixels(float pid){\r \n#line 33 1 \n      return  pid*NUM_COMPONENTS;\r \n#line 34 1 \n  }\r \n#line 35 1 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 36 1 \n      return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 37 1 \n  }\r \n#line 38 1 \n  \r \n#line 39 1 \n  vec2 getSolverCoord(float pid, float uMAXCOL){\r \n#line 40 1 \n      vec2 uv =  vec2(mod(pid,uMAXCOL), floor(pid/uMAXCOL)) / uMAXCOL;\r \n#line 41 1 \n      uv += vec2(1.0/uMAXCOL*0.5); //offset to center of pixel\r \n#line 42 1 \n      return uv;\r \n#line 43 1 \n  }\r \n#line 44 1 \n  \r \n#line 45 1 \n  void main() {\r \n#line 46 1 \n      // read position from texture\r \n#line 47 1 \n      vec2 solverCoord = getSolverCoord(aParticleID, uMAXCOL);\r \n#line 48 1 \n  \r \n#line 49 1 \n      //  vDebug = solverCoord.x;\r \n#line 50 1 \n  \r \n#line 51 1 \n      vec3 position = texture2D(uDataSlot0, solverCoord).xyz;\r \n#line 52 1 \n      vec3 velocity = texture2D(uDataSlot1, solverCoord).xyz;\r \n#line 53 1 \n  \r \n#line 54 1 \n      vSize = texture2D(uDataSlot0, solverCoord).w;\r \n#line 55 1 \n      vColor = texture2D(uDataSlot3, solverCoord).rgb;\r \n#line 56 1 \n      vVel = velocity;\r \n#line 57 1 \n  \r \n#line 58 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position,1);\r \n#line 59 1 \n      gl_PointSize = vSize;\r \n#line 60 1 \n  }\r \n#line 61 1 \n   \n","extension":{},"attribute":{"aParticleID":{"type":"float","value":{"size":"1","stride":"4","offset":"0"},"name":"partiBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"uGeneCount":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uMAXCOL":{"type":"float","value":null},"uDataSlot0":{"type":"sampler2D","value":0},"uDataSlot1":{"type":"sampler2D","value":1},"uDataSlot2":{"type":"sampler2D","value":2},"uDataSlot3":{"type":"sampler2D","value":3}},"file":{"1":"./shaders/glsl/arrow-vert.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var arrowFrag = {"code":"\n#line 1 1 \n  precision mediump float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D uColorSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform float uBlurRadius;\r \n#line 7 1 \n  uniform float uPixelNum;\r \n#line 8 1 \n  \r \n#line 9 1 \n  varying float vSize;\r \n#line 10 1 \n  varying vec3 vColor;\r \n#line 11 1 \n  varying vec3 vVel;\r \n#line 12 1 \n  \r \n#line 13 1 \n  varying float vDebug;\r \n#line 14 1 \n  \r \n#line 15 1 \n  mat2 rotateVelMatrix(vec2 vel) {\r \n#line 16 1 \n  \r \n#line 17 1 \n      vec2 col1 = normalize(vec2(vel.x, -vel.y));\r \n#line 18 1 \n      vec2 col2 = normalize(vec2(vel.y, vel.x));\r \n#line 19 1 \n  \r \n#line 20 1 \n      return mat2(col1, col2);\r \n#line 21 1 \n  }\r \n#line 22 1 \n  \r \n#line 23 1 \n  vec2 rotateUV(vec2 uv, mat2 rot) {\r \n#line 24 1 \n      vec2 centeredUV = uv - vec2(0.5, 0.5);\r \n#line 25 1 \n      vec2 rotatedUV = rot * centeredUV;\r \n#line 26 1 \n      vec2 finalUV = rotatedUV + vec2(0.5);\r \n#line 27 1 \n  \r \n#line 28 1 \n      return finalUV;\r \n#line 29 1 \n  }\r \n#line 30 1 \n  \r \n#line 31 1 \n  void main() {\r \n#line 32 1 \n      // vec2 uv = floor(vec2(gl_PointCoord.x, 1.-gl_PointCoord.y)*uPixelNum)/uPixelNum;\r \n#line 33 1 \n      vec2 uv = vec2(gl_PointCoord.x, 1.0-gl_PointCoord.y);\r \n#line 34 1 \n  \r \n#line 35 1 \n      mat2 rot = rotateVelMatrix(vVel.xy);\r \n#line 36 1 \n  \r \n#line 37 1 \n      vec2 rotUV = rotateUV(uv, rot);\r \n#line 38 1 \n  \r \n#line 39 1 \n      gl_FragColor = texture2D(uColorSampler, rotUV);\r \n#line 40 1 \n  }\r \n#line 41 1 \n   \n","extension":{},"attribute":{},"uniform":{"uColorSampler":{"type":"sampler2D","value":4},"uBlurRadius":{"type":"float","value":null},"uPixelNum":{"type":"float","value":null}},"file":{"1":"./shaders/glsl/arrow-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var aniTestVert = {"code":"uniform vec4 _ANI_TEX_0;  // texWidth.x, texHeight.y, tileSize.z, numFrames.w\r\nuniform float _ANI_TEX_0_FPS;    // frameDuration = numFrames / _ANI_TEX_0_FPS;\r\nvarying vec4 _ANI_TEX_UV; // ux.xy, numCols.z, numRows.w\r\n\r\nvoid _GEN_ANI_TEX_UV(float texWidth, float texHeight, float tileSize, float frame){\r\n  float numCols = texWidth / tileSize;\r\n  float numRows = texHeight / tileSize;\r\n  float row = floor(frame / numCols);\r\n  float col = mod(frame, numCols);\r\n  float uOffset = col / numCols;\r\n  float vOffset = row / numRows;\r\n\r\n  _ANI_TEX_UV = vec4(\r\n      uOffset, // + (uv.x + 0.5) / numCols\r\n      vOffset, //  - (uv.y + 0.5) / numRows\r\n      numCols, \r\n      numRows\r\n  );\r\n}\n#line 1 2 \n  \r \n#line 2 2 \n  \r \n#line 3 2 \n  //https://registry.khronos.org/OpenGL/extensions/OES/OES_texture_float.txt\r \n#line 4 2 \n  \r \n#line 5 2 \n  \r \n#line 6 2 \n  // uniform\r \n#line 7 2 \n  uniform mat4 _uni_projMat;\r \n#line 8 2 \n  uniform mat4 _uni_viewMat;\r \n#line 9 2 \n  \r \n#line 10 2 \n  uniform mat4 _uni_modelMat;\r \n#line 11 2 \n  \r \n#line 12 2 \n  uniform float uTime;\r \n#line 13 2 \n  uniform float uLifeTime;\r \n#line 14 2 \n  uniform float uGeneCount;\r \n#line 15 2 \n  uniform float uPartiCount;\r \n#line 16 2 \n  uniform float uMAXCOL;\r \n#line 17 2 \n  \r \n#line 18 2 \n  \r \n#line 19 2 \n  uniform sampler2D uDataSlot0;\r \n#line 20 2 \n  \r \n#line 21 2 \n  uniform sampler2D uDataSlot1;\r \n#line 22 2 \n  \r \n#line 23 2 \n  uniform sampler2D uDataSlot2;\r \n#line 24 2 \n  \r \n#line 25 2 \n  uniform sampler2D uDataSlot3;\r \n#line 26 2 \n  \r \n#line 27 2 \n  // attribute\r \n#line 28 2 \n  \r \n#line 29 2 \n  attribute float aParticleID;\r \n#line 30 2 \n  \r \n#line 31 2 \n  varying float vSize;\r \n#line 32 2 \n  varying vec3 vColor;\r \n#line 33 2 \n  \r \n#line 34 2 \n  varying float vDebug;\r \n#line 35 2 \n  \r \n#line 36 2 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 37 2 \n  float pidPixels(float pid){\r \n#line 38 2 \n      return  pid*NUM_COMPONENTS;\r \n#line 39 2 \n  }\r \n#line 40 2 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 41 2 \n      return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 42 2 \n  }\r \n#line 43 2 \n  \r \n#line 44 2 \n  vec2 getSolverCoord(float pid, float uMAXCOL){\r \n#line 45 2 \n      vec2 uv =  vec2(mod(pid,uMAXCOL), floor(pid/uMAXCOL)) / uMAXCOL;\r \n#line 46 2 \n      uv += vec2(1.0/uMAXCOL*0.5); // offset to center of pixel\r \n#line 47 2 \n      return uv;\r \n#line 48 2 \n  }\r \n#line 49 2 \n  \r \n#line 50 2 \n  void main() {\r \n#line 51 2 \n  \r \n#line 52 2 \n      // read position from texture\r \n#line 53 2 \n      vec2 solverCoord = getSolverCoord(aParticleID, uMAXCOL);\r \n#line 54 2 \n  \r \n#line 55 2 \n      vec3 position = texture2D(uDataSlot0, solverCoord).xyz;\r \n#line 56 2 \n  \r \n#line 57 2 \n      float percentLife = texture2D(uDataSlot2, solverCoord).z;\r \n#line 58 2 \n  \r \n#line 59 2 \n      // aniTex\r \n#line 60 2 \n      float texWidth = _ANI_TEX_0.x;\r \n#line 61 2 \n      float texHeight = _ANI_TEX_0.y;\r \n#line 62 2 \n      float tileSize = _ANI_TEX_0.z;\r \n#line 63 2 \n      float numFrames = _ANI_TEX_0.w;\r \n#line 64 2 \n      float aniFps = _ANI_TEX_0_FPS;\r \n#line 65 2 \n  \r \n#line 66 2 \n  //    float frame = mod(floor(percentLife * numFrames), numFrames);\r \n#line 67 2 \n      float frame = mod(floor(percentLife * uLifeTime * aniFps), numFrames);\r \n#line 68 2 \n      _GEN_ANI_TEX_UV(texWidth, texHeight, tileSize, frame);\r \n#line 69 2 \n  \r \n#line 70 2 \n      vSize = texture2D(uDataSlot0, solverCoord).w;\r \n#line 71 2 \n      vColor = texture2D(uDataSlot3, solverCoord).xyz;\r \n#line 72 2 \n      vDebug = percentLife;\r \n#line 73 2 \n  \r \n#line 74 2 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position,1);\r \n#line 75 2 \n      gl_PointSize = vSize;\r \n#line 76 2 \n  }\r \n#line 77 2 \n   \n","extension":{"GL_OES_texture_float":"enable","GL_OES_texture_float_linear":"enable"},"attribute":{"aParticleID":{"type":"float","value":{"size":"1","stride":"4","offset":"0"},"name":"partiBuffer"}},"uniform":{"_ANI_TEX_0":{"type":"vec4","value":null},"_ANI_TEX_0_FPS":{"type":"float","value":null},"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"uTime":{"type":"float","value":null},"uLifeTime":{"type":"float","value":null},"uGeneCount":{"type":"float","value":null},"uPartiCount":{"type":"float","value":null},"uMAXCOL":{"type":"float","value":null},"uDataSlot0":{"type":"sampler2D","value":0},"uDataSlot1":{"type":"sampler2D","value":1},"uDataSlot2":{"type":"sampler2D","value":2},"uDataSlot3":{"type":"sampler2D","value":3}},"file":{"1":"./shaders/glsl/solverParti-vert.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var aniTestFrag = {"code":"\n#line 1 1 \n  precision mediump float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D uColorSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform float uBlurRadius;\r \n#line 7 1 \n  uniform float uPixelNum;\r \n#line 8 1 \n  \r \n#line 9 1 \n  varying float vSize;\r \n#line 10 1 \n  varying vec3 vColor;\r \n#line 11 1 \n  varying float vDebug;\r \n#line 12 1 \n  \r \n#line 13 1 \n  varying vec4 _ANI_TEX_UV;   // ux.xy, numCols.z, numRows.w\r \n#line 14 1 \n  \r \n#line 15 1 \n  void main() {\r \n#line 16 1 \n      // vec2 p = floor((2.0 * (gl_PointCoord - 0.5))*uPixelNum)/uPixelNum;\r \n#line 17 1 \n      vec2 aniTexCoord = _ANI_TEX_UV.xy;\r \n#line 18 1 \n      float texColNum = _ANI_TEX_UV.z;\r \n#line 19 1 \n      float texRowNum = _ANI_TEX_UV.w;\r \n#line 20 1 \n      vec2 uv = aniTexCoord + vec2(gl_PointCoord.x / texColNum, gl_PointCoord.y / texRowNum);\r \n#line 21 1 \n      gl_FragColor = texture2D(uColorSampler, uv);\r \n#line 22 1 \n  }\r \n#line 23 1 \n   \n","extension":{},"attribute":{},"uniform":{"uColorSampler":{"type":"sampler2D","value":4},"uBlurRadius":{"type":"float","value":null},"uPixelNum":{"type":"float","value":null}},"file":{"1":"./shaders/glsl/aniTest-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var obstacleVert = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  attribute vec2 aVert;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform vec2 uWorldSize;\r \n#line 9 1 \n  \r \n#line 10 1 \n  void main() {\r \n#line 11 1 \n      float size = 30.0;\r \n#line 12 1 \n      gl_Position = vec4(aVert/uWorldSize, 0, 1);\r \n#line 13 1 \n      gl_PointSize = size * 2.0;\r \n#line 14 1 \n  } \n","extension":{},"attribute":{"aVert":{"type":"vec2","value":{"size":"2","stride":"8","offset":"0"},"name":"obstacleBuffer"}},"uniform":{"uWorldSize":{"type":"vec2","value":null}},"file":{"1":"./shaders/glsl/obstacle-vert.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

var obstacleFrag = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  void main() {\r \n#line 6 1 \n      vec2 p = 2.0 * (gl_PointCoord - 0.5);\r \n#line 7 1 \n      if(length(p) < 1.0){\r \n#line 8 1 \n          vec2 norm = normalize(p * vec2(1, -1));\r \n#line 9 1 \n          gl_FragData[0] = vec4((norm + 1.0) / 2.0, 0, 1);\r \n#line 10 1 \n          //gl_FragColor= vec4((norm + 1.0) / 2.0, 0, 1);\r \n#line 11 1 \n      } else {\r \n#line 12 1 \n          discard;\r \n#line 13 1 \n      }\r \n#line 14 1 \n  }\r \n#line 15 1 \n   \n","extension":{},"attribute":{},"uniform":{},"file":{"1":"./shaders/glsl/obstacle-frag.glsl","2":"./shaders/glsl/aniTest-vert.glsl"}};

export { aniTestFrag, aniTestVert, arrowFrag, arrowVert, basicFrag, basicVert, obstacleFrag, obstacleVert, particle2dVert, particle3dVert, particleFrag, rainFrag, rainVert, screenQuadFrag, screenQuadVert, solverFrag, solverPartiFrag, solverPartiVert };
