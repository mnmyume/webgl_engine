var basicVert = {"code":"\n#line 1 1 \n  uniform mat4 _uni_projMat;\r \n#line 2 1 \n  uniform mat4 _uni_viewMat;\r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform mat4 _uni_modelMat;\r \n#line 5 1 \n  uniform float size;\r \n#line 6 1 \n  \r \n#line 7 1 \n  \r \n#line 8 1 \n  attribute vec3 vertex;\r \n#line 9 1 \n  \r \n#line 10 1 \n  \r \n#line 11 1 \n  attribute vec2 uv;\r \n#line 12 1 \n  \r \n#line 13 1 \n  varying vec2 vUV;\r \n#line 14 1 \n  \r \n#line 15 1 \n  void main(void) {\r \n#line 16 1 \n  \r \n#line 17 1 \n  //    vec3 offset = size * vec3(uv.x, 0, uv.y);\r \n#line 18 1 \n      vec3 position = vertex;\r \n#line 19 1 \n  \r \n#line 20 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(position, 1.0);\r \n#line 21 1 \n      vUV = uv;\r \n#line 22 1 \n  }\r \n#line 23 1 \n   \n","extension":{},"attribute":{"vertex":{"type":"vec3","value":{"size":"3","stride":"20","offset":"0"},"name":"quadBuffer"},"uv":{"type":"vec2","value":{"size":"2","stride":"20","offset":"12"},"name":"quadBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"size":{"type":"float","value":null}},"file":{"1":"./shaders/glsl/basic-vert.glsl"}};

var basicFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  //\r \n#line 5 1 \n  \r \n#line 6 1 \n  \r \n#line 7 1 \n  uniform vec3 color;\r \n#line 8 1 \n  \r \n#line 9 1 \n  \r \n#line 10 1 \n  void main(void) {\r \n#line 11 1 \n  \r \n#line 12 1 \n      vec2 uv = gl_FragCoord.xy;  \r \n#line 13 1 \n  \r \n#line 14 1 \n      gl_FragColor = vec4(color,1);\r \n#line 15 1 \n  }\r \n#line 16 1 \n   \n","extension":{},"attribute":{},"uniform":{"color":{"type":"vec3","value":[0,1,0]}},"file":{"1":"./shaders/glsl/basic-frag.glsl"}};

var particle3dVert = {"code":"\n#line 1 1 \n  uniform float duration;\r \n#line 2 1 \n  uniform float time;\r \n#line 3 1 \n  uniform float frameDuration;\r \n#line 4 1 \n  uniform float numFrames;\r \n#line 5 1 \n  uniform mat4 _uni_projMat;\r \n#line 6 1 \n  uniform mat4 _uni_viewMat;\r \n#line 7 1 \n  uniform mat4 _uni_modelMat;\r \n#line 8 1 \n  \r \n#line 9 1 \n  // Incoming vertex attributes\r \n#line 10 1 \n  attribute vec4 uvLifeTimeFrameStart; // uv, lifeTime, frameStart\r \n#line 11 1 \n  attribute vec4 positionStartTime;    // position.xyz, startTime\r \n#line 12 1 \n  attribute vec4 velocityStartSize;    // velocity.xyz, startSize\r \n#line 13 1 \n  attribute vec4 accelerationEndSize;  // acceleration.xyz, endSize\r \n#line 14 1 \n  attribute vec4 spinStartSpinSpeed;   // spinStart.x, spinSpeed.y\r \n#line 15 1 \n  attribute vec4 orientation;          // orientation quaternion\r \n#line 16 1 \n  attribute vec4 colorMult;            // multiplies color and ramp textures\r \n#line 17 1 \n  \r \n#line 18 1 \n  // Outgoing variables to fragment shader\r \n#line 19 1 \n  varying vec2 outputTexcoord;\r \n#line 20 1 \n  varying float outputPercentLife;\r \n#line 21 1 \n  varying vec4 outputColorMult;\r \n#line 22 1 \n  \r \n#line 23 1 \n  void main(void) {\r \n#line 24 1 \n      vec2 uv = uvLifeTimeFrameStart.xy;\r \n#line 25 1 \n      float lifeTime = uvLifeTimeFrameStart.z;\r \n#line 26 1 \n      float frameStart = uvLifeTimeFrameStart.w;\r \n#line 27 1 \n      vec3 position = positionStartTime.xyz;\r \n#line 28 1 \n      float startTime = positionStartTime.w;\r \n#line 29 1 \n      vec3 velocity = velocityStartSize.xyz;\r \n#line 30 1 \n      float startSize = velocityStartSize.w;\r \n#line 31 1 \n      vec3 acceleration = accelerationEndSize.xyz;\r \n#line 32 1 \n      float endSize = accelerationEndSize.w;\r \n#line 33 1 \n      float spinStart = spinStartSpinSpeed.x;\r \n#line 34 1 \n      float spinSpeed = spinStartSpinSpeed.y;\r \n#line 35 1 \n      \r \n#line 36 1 \n      float localTime = mod((time - startTime), duration);\r \n#line 37 1 \n      float percentLife = localTime / lifeTime;\r \n#line 38 1 \n      float frame = mod(floor(localTime / frameDuration + frameStart),\r \n#line 39 1 \n                  numFrames);\r \n#line 40 1 \n      float uOffset = frame / numFrames;\r \n#line 41 1 \n      float u = uOffset + (uv.x + 0.5) * (1. / numFrames);\r \n#line 42 1 \n  \r \n#line 43 1 \n      outputTexcoord = vec2(u, uv.y + 0.5);\r \n#line 44 1 \n      outputColorMult = colorMult;\r \n#line 45 1 \n      \r \n#line 46 1 \n      float size = mix(startSize, endSize, percentLife);\r \n#line 47 1 \n      size = (percentLife < 0. || percentLife > 1.) ? 0. : size;\r \n#line 48 1 \n      float s = sin(spinStart + spinSpeed * localTime);\r \n#line 49 1 \n      float c = cos(spinStart + spinSpeed * localTime);\r \n#line 50 1 \n      vec4 rotatedPoint = vec4((uv.x * c + uv.y * s) * size, 0., \r \n#line 51 1 \n                               (uv.x * s - uv.y * c) * size, 1.);\r \n#line 52 1 \n      vec3 center = velocity * localTime +\r \n#line 53 1 \n                    acceleration * localTime * localTime + \r \n#line 54 1 \n                    position;\r \n#line 55 1 \n      vec4 q2 = orientation + orientation;\r \n#line 56 1 \n      vec4 qx = orientation.xxxw * q2.xyzx;\r \n#line 57 1 \n      vec4 qy = orientation.xyyw * q2.xyzy;\r \n#line 58 1 \n      vec4 qz = orientation.xxzw * q2.xxzz;\r \n#line 59 1 \n      mat4 localMatrix = mat4(\r \n#line 60 1 \n          (1.0 - qy.y) - qz.z, \r \n#line 61 1 \n          qx.y + qz.w, \r \n#line 62 1 \n          qx.z - qy.w,\r \n#line 63 1 \n          0,\r \n#line 64 1 \n          qx.y - qz.w, \r \n#line 65 1 \n          (1.0 - qx.x) - qz.z, \r \n#line 66 1 \n          qy.z + qx.w,\r \n#line 67 1 \n          0,\r \n#line 68 1 \n          qx.z + qy.w, \r \n#line 69 1 \n          qy.z - qx.w, \r \n#line 70 1 \n          (1.0 - qx.x) - qy.y,\r \n#line 71 1 \n          0,\r \n#line 72 1 \n          center.x, center.y, center.z, 1);\r \n#line 73 1 \n  \r \n#line 74 1 \n      rotatedPoint = localMatrix * rotatedPoint;\r \n#line 75 1 \n  \r \n#line 76 1 \n      outputPercentLife = percentLife;\r \n#line 77 1 \n  \r \n#line 78 1 \n      gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * rotatedPoint;\r \n#line 79 1 \n  } \n","extension":{},"attribute":{"uvLifeTimeFrameStart":{"type":"vec4","value":null},"positionStartTime":{"type":"vec4","value":null},"velocityStartSize":{"type":"vec4","value":null},"accelerationEndSize":{"type":"vec4","value":null},"spinStartSpinSpeed":{"type":"vec4","value":null},"orientation":{"type":"vec4","value":null},"colorMult":{"type":"vec4","value":null}},"uniform":{"duration":{"type":"float","value":null},"time":{"type":"float","value":null},"frameDuration":{"type":"float","value":null},"numFrames":{"type":"float","value":null},"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":null}},"file":{"1":"./shaders/glsl/particle3d-vert.glsl"}};

var particle2dVert = {"code":"#line 1 1 \n  uniform vec4 _ANI_TEX_0;  // texWidth.x, texHeight.y, tileSize.z, numFrames.w\r \n#line 2 1 \n  uniform float _ANI_TEX_0_FPS;    // frameDuration = numFrames / _ANI_TEX_0_FPS;\r \n#line 3 1 \n  varying vec4 _ANI_TEX_UV; // ux.xy, numCols.z, numRows.w\r \n#line 4 1 \n  \r \n#line 5 1 \n  void _GEN_ANI_TEX_UV(float texWidth, float texHeight, float tileSize, float frame){\r \n#line 6 1 \n    float numCols = texWidth / tileSize;\r \n#line 7 1 \n    float numRows = texHeight / tileSize;\r \n#line 8 1 \n    float row = floor(frame / numCols);\r \n#line 9 1 \n    float col = mod(frame, numCols);\r \n#line 10 1 \n    float uOffset = col / numCols;\r \n#line 11 1 \n    float vOffset = row / numRows;\r \n#line 12 1 \n  \r \n#line 13 1 \n    _ANI_TEX_UV = vec4(\r \n#line 14 1 \n        uOffset, // + (uv.x + 0.5) / numCols\r \n#line 15 1 \n        1.0 - vOffset, //  - (uv.y + 0.5) / numRows  \r \n#line 16 1 \n        numCols, \r \n#line 17 1 \n        numRows\r \n#line 18 1 \n    );\r \n#line 19 1 \n  } \n\n#line 1 2 \n  \r \n#line 2 2 \n  \r \n#line 3 2 \n  //https://registry.khronos.org/OpenGL/extensions/OES/OES_texture_float.txt\r \n#line 4 2 \n  \r \n#line 5 2 \n  \r \n#line 6 2 \n  // uniform\r \n#line 7 2 \n  uniform mat4 _uni_projMat;\r \n#line 8 2 \n  uniform mat4 _uni_viewMat;\r \n#line 9 2 \n  uniform mat4 uVInverseMatrix;\r \n#line 10 2 \n  uniform mat4 _uni_modelMat;\r \n#line 11 2 \n  uniform float duration;\r \n#line 12 2 \n  uniform float time;\r \n#line 13 2 \n  uniform float partiCount;\r \n#line 14 2 \n  uniform float numGen;\r \n#line 15 2 \n  uniform vec3 gravity;\r \n#line 16 2 \n  uniform float lifeTime;\r \n#line 17 2 \n  \r \n#line 18 2 \n  \r \n#line 19 2 \n  // PixelOne(pos.xyz, startSize.w) PixelTwo(linearVel.xyz, endSize.w)\r \n#line 20 2 \n  \r \n#line 21 2 \n  uniform sampler2D generatorSampler;\r \n#line 22 2 \n  \r \n#line 23 2 \n  \r \n#line 24 2 \n  #define ANI_TEX\r \n#line 25 2 \n  /* MACRO */\r \n#line 26 2 \n  #ifdef ANI_TEX\r \n#line 27 2 \n  #endif  /* MACRO ANI_TEX*/\r \n#line 28 2 \n  \r \n#line 29 2 \n  // attribute\r \n#line 30 2 \n  attribute float startTime;\r \n#line 31 2 \n  attribute float particleID;\r \n#line 32 2 \n  \r \n#line 33 2 \n  varying float outputPercentLife;\r \n#line 34 2 \n  \r \n#line 35 2 \n  const float NUM_COMPONENTS = 2.0;\r \n#line 36 2 \n  float pidPixels(float pid){\r \n#line 37 2 \n    return  pid*NUM_COMPONENTS;\r \n#line 38 2 \n  }\r \n#line 39 2 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 40 2 \n    return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 41 2 \n  }\r \n#line 42 2 \n  \r \n#line 43 2 \n  void main() {\r \n#line 44 2 \n    \r \n#line 45 2 \n    // aniTex\r \n#line 46 2 \n    float texWidth = _ANI_TEX_0.x;\r \n#line 47 2 \n    float texHeight = _ANI_TEX_0.y;\r \n#line 48 2 \n    float tileSize = _ANI_TEX_0.z;\r \n#line 49 2 \n    float numFrames = _ANI_TEX_0.w;\r \n#line 50 2 \n    float frameDuration = 1.0 / _ANI_TEX_0_FPS;\r \n#line 51 2 \n  \r \n#line 52 2 \n    float localTime = mod(time - startTime, lifeTime) ;\r \n#line 53 2 \n    float percentLife = localTime / lifeTime;\r \n#line 54 2 \n    float frame = mod(floor(localTime / frameDuration),\r \n#line 55 2 \n                      numFrames);\r \n#line 56 2 \n    float generation = floor((time - startTime) / duration);\r \n#line 57 2 \n  \r \n#line 58 2 \n    float componentOffset = 0.0;\r \n#line 59 2 \n    float posTexCoordU = pidPixelsOffset(particleID, componentOffset) / pidPixels(partiCount);\r \n#line 60 2 \n    float posTexCoordV = 1.0 - (generation / numGen + 0.5 / numGen);  \r \n#line 61 2 \n    vec2 posTexCoord = vec2(posTexCoordU, posTexCoordV);\r \n#line 62 2 \n    vec3 position = texture2D(generatorSampler, posTexCoord).xyz;\r \n#line 63 2 \n    float startSize = texture2D(generatorSampler, posTexCoord).w;\r \n#line 64 2 \n  \r \n#line 65 2 \n    componentOffset = 1.0;\r \n#line 66 2 \n    float linearVelTexCoordU =  pidPixelsOffset(particleID, componentOffset) / pidPixels(partiCount);\r \n#line 67 2 \n    float linearVelTexCoordV = 1.0 - (generation / numGen + 0.5 / numGen);  \r \n#line 68 2 \n    vec2 linearVelTexCoord = vec2(linearVelTexCoordU, linearVelTexCoordV);\r \n#line 69 2 \n    vec3 linearVelocity = texture2D(generatorSampler, linearVelTexCoord).xyz;\r \n#line 70 2 \n    float endSize = texture2D(generatorSampler, linearVelTexCoord).w;\r \n#line 71 2 \n  \r \n#line 72 2 \n    _GEN_ANI_TEX_UV(texWidth, texHeight, tileSize, frame);\r \n#line 73 2 \n  \r \n#line 74 2 \n    float size = mix(startSize, endSize, percentLife);\r \n#line 75 2 \n    size = (percentLife < 0. || percentLife > 1.) ? 0. : size;\r \n#line 76 2 \n  \r \n#line 77 2 \n    vec3 velocity = linearVelocity;\r \n#line 78 2 \n    vec3 localPosition = velocity * localTime +\r \n#line 79 2 \n                         // acceleration * localTime * localTime + \r \n#line 80 2 \n                         position; \r \n#line 81 2 \n                         \r \n#line 82 2 \n    outputPercentLife = percentLife;\r \n#line 83 2 \n    gl_PointSize = size; \r \n#line 84 2 \n    gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(localPosition, 1.);\r \n#line 85 2 \n  }\r \n#line 86 2 \n   \n","extension":{"GL_OES_texture_float":"enable","GL_OES_texture_float_linear":"enable"},"attribute":{"startTime":{"type":"float","value":null},"particleID":{"type":"float","value":null}},"uniform":{"_ANI_TEX_0":{"type":"vec4","value":null},"_ANI_TEX_0_FPS":{"type":"float","value":null},"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"uVInverseMatrix":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":null},"duration":{"type":"float","value":null},"time":{"type":"float","value":null},"partiCount":{"type":"float","value":null},"numGen":{"type":"float","value":null},"gravity":{"type":"vec3","value":null},"lifeTime":{"type":"float","value":null},"generatorSampler":{"type":"sampler2D","value":2}},"file":{"1":"./shaders/glsl/testFolder/aniTex.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var particleFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D rampSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  \r \n#line 7 1 \n  uniform sampler2D colorSampler;\r \n#line 8 1 \n  \r \n#line 9 1 \n  // Incoming variables from vertex shader\r \n#line 10 1 \n  varying float outputPercentLife;\r \n#line 11 1 \n  varying vec4 _ANI_TEX_UV;   // ux.xy, numCols.z, numRows.w\r \n#line 12 1 \n  \r \n#line 13 1 \n  void main(void) {\r \n#line 14 1 \n      vec2 pointUV = vec2(_ANI_TEX_UV.x, _ANI_TEX_UV.y);\r \n#line 15 1 \n      float numCols = _ANI_TEX_UV.z;\r \n#line 16 1 \n      float numRows = _ANI_TEX_UV.w;\r \n#line 17 1 \n      vec2 pointCoord = pointUV + vec2(gl_PointCoord.x / numCols, gl_PointCoord.y / numRows);\r \n#line 18 1 \n      vec4 colorMult = texture2D(rampSampler, vec2(outputPercentLife, 0.5));\r \n#line 19 1 \n      gl_FragColor = texture2D(colorSampler, pointCoord);    // * colorMult;\r \n#line 20 1 \n      // gl_FragColor = colorMult;\r \n#line 21 1 \n  } \n","extension":{},"attribute":{},"uniform":{"rampSampler":{"type":"sampler2D","value":0},"colorSampler":{"type":"sampler2D","value":1}},"file":{"1":"./shaders/glsl/particle-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var screenQuadVert = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  attribute vec2 quad;\r \n#line 7 1 \n  \r \n#line 8 1 \n  void main() {\r \n#line 9 1 \n      gl_Position = vec4(quad, 0.0, 1.0);\r \n#line 10 1 \n  }\r \n#line 11 1 \n   \n","extension":{},"attribute":{"quad":{"type":"vec2","value":{"size":"2","stride":"8","offset":"0"},"name":"quadBuffer"}},"uniform":{},"file":{"1":"./shaders/glsl/screenQuad-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var screenQuadFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  void main(void) {\r \n#line 4 1 \n  \r \n#line 5 1 \n      vec2 uv = gl_FragCoord.xy;  \r \n#line 6 1 \n  \r \n#line 7 1 \n      gl_FragColor = vec4(0.1,0.2,0.3,1);\r \n#line 8 1 \n  }\r \n#line 9 1 \n   \n","extension":{},"attribute":{},"uniform":{},"file":{"1":"./shaders/glsl/screenQuad-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var solverFrag = {"code":"\n#line 1 1 \n  precision highp float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform sampler2D posSampler;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform sampler2D velSampler;\r \n#line 9 1 \n  \r \n#line 10 1 \n  uniform sampler2D propertySampler; // particleID.x, startTime.y, percentLife.z, generation.w\r \n#line 11 1 \n  \r \n#line 12 1 \n  uniform sampler2D obsSampler;\r \n#line 13 1 \n  \r \n#line 14 1 \n  \r \n#line 15 1 \n  uniform float deltaTime;\r \n#line 16 1 \n  \r \n#line 17 1 \n  \r \n#line 18 1 \n  uniform mat4 emitter_transform;\r \n#line 19 1 \n  \r \n#line 20 1 \n  uniform vec4 grid;  // width.r, height.g, corner.ba\r \n#line 21 1 \n  uniform vec2 worldSize;\r \n#line 22 1 \n  uniform vec2 resolution;\r \n#line 23 1 \n  uniform float time;\r \n#line 24 1 \n  \r \n#line 25 1 \n  // \r \n#line 26 1 \n  uniform float duration; // -1 infinite\r \n#line 27 1 \n  uniform float geneCount;\r \n#line 28 1 \n  uniform float lifeTime;\r \n#line 29 1 \n  uniform float partiCount;\r \n#line 30 1 \n  \r \n#line 31 1 \n  float dot2(vec2 a, vec2 b) {\r \n#line 32 1 \n      return a.x * b.x + a.y * b.y;\r \n#line 33 1 \n  }\r \n#line 34 1 \n  \r \n#line 35 1 \n  float halton(int base, int index) {\r \n#line 36 1 \n      float result = 0.0;\r \n#line 37 1 \n      float digitWeight = 1.0;\r \n#line 38 1 \n      digitWeight = digitWeight / float(base); \r \n#line 39 1 \n      int nominator;\r \n#line 40 1 \n      for (int i = 0; i < 10; i++) {\r \n#line 41 1 \n          nominator = index - (index / base) * base;  // int mod\r \n#line 42 1 \n          result += float(nominator) * digitWeight;\r \n#line 43 1 \n          index = index / base;\r \n#line 44 1 \n          digitWeight = digitWeight / float(base);\r \n#line 45 1 \n          if (index == 0) {\r \n#line 46 1 \n              break;\r \n#line 47 1 \n          }\r \n#line 48 1 \n      }\r \n#line 49 1 \n      return result;\r \n#line 50 1 \n  }\r \n#line 51 1 \n  \r \n#line 52 1 \n  vec3 gravityField(vec3 vel) {\r \n#line 53 1 \n      vec3 gravity = vec3(0, -10, 0);\r \n#line 54 1 \n      vel = vel + gravity * deltaTime;\r \n#line 55 1 \n      \r \n#line 56 1 \n      return vel;\r \n#line 57 1 \n  }\r \n#line 58 1 \n  \r \n#line 59 1 \n  vec3 velField(vec3 pos, vec3 scalar) {\r \n#line 60 1 \n      float x = fract(sin(dot2(pos.xy,vec2(12.9898,78.233)))* 43758.5453)-0.5;\r \n#line 61 1 \n      float y = fract(sin(dot2(pos.xy,vec2(62.2364,94.674)))* 62159.8432)-0.5;\r \n#line 62 1 \n      float z = fract(sin(dot2(pos.xy,vec2(989.2364,94.674)))* 12349.8432)-0.5;\r \n#line 63 1 \n  \r \n#line 64 1 \n      float randomMagnitude1 = sin(time*2.5)*0.7;\r \n#line 65 1 \n      float randomMagnitude2 = cos(time*2.5)*0.7;\r \n#line 66 1 \n  \r \n#line 67 1 \n      vec3 d = vec3(x*sin(y),y,z)*randomMagnitude1 + vec3(y,x,z)*randomMagnitude2;\r \n#line 68 1 \n  \r \n#line 69 1 \n      return scalar*normalize(d);\r \n#line 70 1 \n  }\r \n#line 71 1 \n  \r \n#line 72 1 \n  void updatePosVel(inout vec3 pos, inout vec3 vel, vec2 obs, vec2 index) {\r \n#line 73 1 \n      pos = pos + vel * deltaTime;\r \n#line 74 1 \n      \r \n#line 75 1 \n      // reset pos if particle out boundary\r \n#line 76 1 \n      // float width = worldSize.x / 2.0;\r \n#line 77 1 \n      // float height = worldSize.y / 2.0;\r \n#line 78 1 \n      // int n = int(index.x+1.0 + index.y*resolution.x);\r \n#line 79 1 \n      // vec2 random = vec2(halton(2, n), halton(3, n));\r \n#line 80 1 \n      // if(abs(pos.x) > width || abs(pos.y) > height){\r \n#line 81 1 \n      //     pos.y = grid.g; \r \n#line 82 1 \n      //     pos.z = grid.a + grid.r * random.y;\r \n#line 83 1 \n      //     pos.x = grid.b + grid.r * random.x; \r \n#line 84 1 \n      //     vel.x = 0.0;    \r \n#line 85 1 \n      //     vel.y = 0.0;    \r \n#line 86 1 \n      // }\r \n#line 87 1 \n  \r \n#line 88 1 \n      // obstacle\r \n#line 89 1 \n      if (obs.y > 0.0) {\r \n#line 90 1 \n          pos.xy = pos.xy - vel.xy * deltaTime;\r \n#line 91 1 \n          pos.xy = pos.xy + obs;\r \n#line 92 1 \n          if (length(vel) < 0.5) {\r \n#line 93 1 \n              vel.xy = obs * 0.5; // velocity too low, jiggle outward\r \n#line 94 1 \n          } else {\r \n#line 95 1 \n              vel.xy = reflect(vel.xy, obs) * 0.25; // bounce, restitution\r \n#line 96 1 \n          }\r \n#line 97 1 \n      }\r \n#line 98 1 \n  }\r \n#line 99 1 \n  \r \n#line 100 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 101 1 \n  float pidPixels(float pid){\r \n#line 102 1 \n    return  pid*NUM_COMPONENTS;\r \n#line 103 1 \n  }\r \n#line 104 1 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 105 1 \n    return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 106 1 \n  }\r \n#line 107 1 \n  \r \n#line 108 1 \n  void main() {\r \n#line 109 1 \n  \r \n#line 110 1 \n      vec2 uv = gl_FragCoord.xy / resolution;    \r \n#line 111 1 \n  \r \n#line 112 1 \n      float particleID = texture2D(propertySampler, uv).x;\r \n#line 113 1 \n      float startTime = texture2D(propertySampler, uv).y;\r \n#line 114 1 \n      float percentLife = texture2D(propertySampler, uv).z;\r \n#line 115 1 \n      float generation = texture2D(propertySampler, uv).w;\r \n#line 116 1 \n  \r \n#line 117 1 \n      // read position and velocity from texture\r \n#line 118 1 \n      float componentOffset = 0.0;\r \n#line 119 1 \n      float texCoordU = pidPixelsOffset(particleID, componentOffset) / pidPixels(partiCount);\r \n#line 120 1 \n      float texCoordV = 0.5;  \r \n#line 121 1 \n      vec2 texCoord = vec2(texCoordU, texCoordV);\r \n#line 122 1 \n  \r \n#line 123 1 \n      vec2 emitterPos = texture2D(posSampler, texCoord).xy;\r \n#line 124 1 \n      float size = texture2D(posSampler, texCoord).z;\r \n#line 125 1 \n      //vec4 position = emitter_transform * vec4(emitterPos.x, 0, emitterPos.y, 1);\r \n#line 126 1 \n      vec3 pos = vec3(emitterPos.x,0.0,emitterPos.y);\r \n#line 127 1 \n      vec3 vel = texture2D(velSampler, texCoord).xyz;\r \n#line 128 1 \n  \r \n#line 129 1 \n  //    vec4 obstacle = texture2D(obsSampler, (pos.xy + 0.5*worldSize)/worldSize);\r \n#line 130 1 \n  //    vec2 obs = vec2(obstacle.x, obstacle.y)*2.0 - 1.0;\r \n#line 131 1 \n  \r \n#line 132 1 \n  //    float localTime = 0.0;\r \n#line 133 1 \n  //    if(time - startTime > 0.0) {\r \n#line 134 1 \n  //        localTime = mod(time - startTime, lifeTime);\r \n#line 135 1 \n  //    }\r \n#line 136 1 \n  //\r \n#line 137 1 \n  //    percentLife = localTime / lifeTime;\r \n#line 138 1 \n  //\r \n#line 139 1 \n  //    if(localTime > 0.0 && percentLife < 1.0) {\r \n#line 140 1 \n  //        vel = gravityField(vel);\r \n#line 141 1 \n  //        vel = vel + velField(pos, vec3(.0,.0,.0));\r \n#line 142 1 \n  //        updatePosVel(pos, vel, obs, gl_FragCoord.xy);\r \n#line 143 1 \n  //    }\r \n#line 144 1 \n  //\r \n#line 145 1 \n  //\r \n#line 146 1 \n  //    bool isEmitterActive = duration > 0.0 && time < duration;\r \n#line 147 1 \n  //    if(percentLife > 1.0 && isEmitterActive){   // particle is dead\r \n#line 148 1 \n  //        //read emitter texture map\r \n#line 149 1 \n  //        generation = floor((time - startTime)/lifeTime);\r \n#line 150 1 \n  //        texCoordV = 1.0 - (generation / geneCount + 0.5 / geneCount);\r \n#line 151 1 \n  //        texCoord = vec2(texCoordU, texCoordV);\r \n#line 152 1 \n  //        pos = texture2D(posSampler, texCoord).xyz;\r \n#line 153 1 \n  //        vel = texture2D(velSampler, texCoord).xyz;\r \n#line 154 1 \n  //    }\r \n#line 155 1 \n  \r \n#line 156 1 \n  \r \n#line 157 1 \n      gl_FragData[0] = vec4(emitterPos, 0.0,1.0);\r \n#line 158 1 \n  //    gl_FragData[1] = vec4(vel,1);\r \n#line 159 1 \n  //    gl_FragData[2] = vec4(particleID, startTime, percentLife, generation);\r \n#line 160 1 \n  //    gl_FragData[3] = vec4(1.0,.0,1.0,1.0);\r \n#line 161 1 \n  \r \n#line 162 1 \n  } \n","extension":{"GL_EXT_draw_buffers":"require","GL_OES_texture_float":"enable"},"attribute":{},"uniform":{"posSampler":{"type":"sampler2D","value":0},"velSampler":{"type":"sampler2D","value":1},"propertySampler":{"type":"sampler2D","value":2},"obsSampler":{"type":"sampler2D","value":3},"deltaTime":{"type":"float","value":0.01666},"emitter_transform":{"type":"mat4","value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"grid":{"type":"vec4","value":null},"worldSize":{"type":"vec2","value":null},"resolution":{"type":"vec2","value":null},"time":{"type":"float","value":null},"duration":{"type":"float","value":null},"geneCount":{"type":"float","value":null},"lifeTime":{"type":"float","value":null},"partiCount":{"type":"float","value":null}},"file":{"1":"./shaders/glsl/solver-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var solverPartiVert = {"code":"\n#line 1 1 \n  // uniform\r \n#line 2 1 \n  uniform mat4 _uni_projMat;\r \n#line 3 1 \n  uniform mat4 _uni_viewMat;\r \n#line 4 1 \n  uniform mat4 _uni_modelMat;\r \n#line 5 1 \n  \r \n#line 6 1 \n  uniform float geneCount;\r \n#line 7 1 \n  uniform float partiCount;\r \n#line 8 1 \n  \r \n#line 9 1 \n  \r \n#line 10 1 \n  uniform sampler2D posSampler;\r \n#line 11 1 \n  \r \n#line 12 1 \n  uniform sampler2D velSampler;\r \n#line 13 1 \n  \r \n#line 14 1 \n  uniform sampler2D propertySampler;  // particleID.x, startTime.y, percentLife.z, generation.w\r \n#line 15 1 \n  \r \n#line 16 1 \n  // attribute\r \n#line 17 1 \n  \r \n#line 18 1 \n  attribute float particleID;\r \n#line 19 1 \n  \r \n#line 20 1 \n  varying float outputPercentLife;\r \n#line 21 1 \n  \r \n#line 22 1 \n  const float NUM_COMPONENTS = 1.0;\r \n#line 23 1 \n  float pidPixels(float pid){\r \n#line 24 1 \n    return  pid*NUM_COMPONENTS;\r \n#line 25 1 \n  }\r \n#line 26 1 \n  float pidPixelsOffset(float pid, float offset){\r \n#line 27 1 \n    return  pid*NUM_COMPONENTS + offset + 0.5;\r \n#line 28 1 \n  }\r \n#line 29 1 \n  \r \n#line 30 1 \n  void main(void) {\r \n#line 31 1 \n  \r \n#line 32 1 \n    // read property from texture\r \n#line 33 1 \n    float propOffset = 0.0;\r \n#line 34 1 \n    float propTexCoordU = pidPixelsOffset(particleID, propOffset) / pidPixels(partiCount);\r \n#line 35 1 \n    float propTexCoordV = 0.5;\r \n#line 36 1 \n    vec2 propTexCoord = vec2(propTexCoordU, propTexCoordV);\r \n#line 37 1 \n  \r \n#line 38 1 \n    float startTime = texture2D(propertySampler, propTexCoord).y;\r \n#line 39 1 \n    float percentLife = texture2D(propertySampler, propTexCoord).z;\r \n#line 40 1 \n    float generation = texture2D(propertySampler, propTexCoord).w;\r \n#line 41 1 \n  \r \n#line 42 1 \n    // read position from texture\r \n#line 43 1 \n    float componentOffset = 0.0;\r \n#line 44 1 \n    float posTexCoordU = pidPixelsOffset(particleID, componentOffset) / pidPixels(partiCount);\r \n#line 45 1 \n    float posTexCoordV = 1.0 - (generation / geneCount + 0.5 / geneCount);  \r \n#line 46 1 \n    vec2 posTexCoord = vec2(posTexCoordU, posTexCoordV);\r \n#line 47 1 \n  \r \n#line 48 1 \n    vec3 position = texture2D(posSampler, posTexCoord).xyz;\r \n#line 49 1 \n  \r \n#line 50 1 \n    float size = texture2D(posSampler, posTexCoord).w;\r \n#line 51 1 \n    size = (percentLife < 0. || percentLife > 1.) ? 0. : size;\r \n#line 52 1 \n    \r \n#line 53 1 \n    outputPercentLife = percentLife;\r \n#line 54 1 \n  \r \n#line 55 1 \n    gl_PointSize = 40.0;//size;\r \n#line 56 1 \n    gl_Position = _uni_projMat * _uni_viewMat * _uni_modelMat * vec4(0.0,0.0,0.0, 1.0);\r \n#line 57 1 \n  }\r \n#line 58 1 \n   \n","extension":{},"attribute":{"particleID":{"type":"float","value":{"size":"1","stride":"4","offset":"0"},"name":"partiBuffer"}},"uniform":{"_uni_projMat":{"type":"mat4","value":null},"_uni_viewMat":{"type":"mat4","value":null},"_uni_modelMat":{"type":"mat4","value":null},"geneCount":{"type":"float","value":null},"partiCount":{"type":"float","value":null},"posSampler":{"type":"sampler2D","value":0},"velSampler":{"type":"sampler2D","value":1},"propertySampler":{"type":"sampler2D","value":2}},"file":{"1":"./shaders/glsl/solverParti-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var solverPartiFrag = {"code":"\n#line 1 1 \n  precision mediump float;\r \n#line 2 1 \n  \r \n#line 3 1 \n  \r \n#line 4 1 \n  uniform sampler2D colorSampler;\r \n#line 5 1 \n  \r \n#line 6 1 \n  varying float outputPercentLife;\r \n#line 7 1 \n  \r \n#line 8 1 \n  void main(void) {\r \n#line 9 1 \n      vec2 p = 2.0 * (gl_PointCoord - 0.5);\r \n#line 10 1 \n      if(outputPercentLife >= 0.0 && length(p) < 1.0) {\r \n#line 11 1 \n  //        gl_FragColor = texture2D(colorSampler, gl_PointCoord);\r \n#line 12 1 \n           gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r \n#line 13 1 \n      } else {\r \n#line 14 1 \n          discard;\r \n#line 15 1 \n      }\r \n#line 16 1 \n  }\r \n#line 17 1 \n   \n","extension":{},"attribute":{},"uniform":{"colorSampler":{"type":"sampler2D","value":3}},"file":{"1":"./shaders/glsl/solverParti-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var obstacleVert = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  \r \n#line 6 1 \n  attribute vec2 vert;\r \n#line 7 1 \n  \r \n#line 8 1 \n  uniform vec2 worldSize;\r \n#line 9 1 \n  \r \n#line 10 1 \n  void main() {\r \n#line 11 1 \n      float size = 30.0;\r \n#line 12 1 \n      gl_Position = vec4(vert/worldSize, 0, 1);\r \n#line 13 1 \n      gl_PointSize = size * 2.0;\r \n#line 14 1 \n  } \n","extension":{},"attribute":{"vert":{"type":"vec2","value":{"size":"2","stride":"8","offset":"0"},"name":"obstacleBuffer"}},"uniform":{"worldSize":{"type":"vec2","value":null}},"file":{"1":"./shaders/glsl/obstacle-vert.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

var obstacleFrag = {"code":"\n#line 1 1 \n  #ifdef GL_ES\r \n#line 2 1 \n  precision highp float;\r \n#line 3 1 \n  #endif\r \n#line 4 1 \n  \r \n#line 5 1 \n  void main() {\r \n#line 6 1 \n      vec2 p = 2.0 * (gl_PointCoord - 0.5);\r \n#line 7 1 \n      if(length(p) < 1.0){\r \n#line 8 1 \n          vec2 norm = normalize(p * vec2(1, -1));\r \n#line 9 1 \n          gl_FragData[0] = vec4((norm + 1.0) / 2.0, 0, 1);\r \n#line 10 1 \n          //gl_FragColor= vec4((norm + 1.0) / 2.0, 0, 1);\r \n#line 11 1 \n      } else {\r \n#line 12 1 \n          discard;\r \n#line 13 1 \n      }\r \n#line 14 1 \n  }\r \n#line 15 1 \n   \n","extension":{},"attribute":{},"uniform":{},"file":{"1":"./shaders/glsl/obstacle-frag.glsl","2":"./shaders/glsl/particle2d-vert.glsl"}};

export { basicFrag, basicVert, obstacleFrag, obstacleVert, particle2dVert, particle3dVert, particleFrag, screenQuadFrag, screenQuadVert, solverFrag, solverPartiFrag, solverPartiVert };
