var basicVert = {"source":"#line 0:shaders/glsl/testFolder/aniTex.glsl\n  uniform vec4 _ANI_TEX_0;  // texWidth.x, texHeight.y, tileSize.z, numFrames.w\r \n#line 1:shaders/glsl/testFolder/aniTex.glsl\n  uniform float _ANI_TEX_0_FPS;    // frameDuration = numFrames / _ANI_TEX_0_FPS;\r \n#line 2:shaders/glsl/testFolder/aniTex.glsl\n  varying vec2 _ANI_TEX_UV;\r \n#line 3:shaders/glsl/testFolder/aniTex.glsl\n  \r \n#line 4:shaders/glsl/testFolder/aniTex.glsl\n  void _GEN_ANI_TEX_UV(float texWidth, float texHeight, float tileSize, float frame, vec2 uv){\r \n#line 5:shaders/glsl/testFolder/aniTex.glsl\n    float numCols = texWidth / tileSize;\r \n#line 6:shaders/glsl/testFolder/aniTex.glsl\n    float numRows = texHeight / tileSize;\r \n#line 7:shaders/glsl/testFolder/aniTex.glsl\n    int row = int(frame / numCols);\r \n#line 8:shaders/glsl/testFolder/aniTex.glsl\n    int col = int(mod(frame, numCols));\r \n#line 9:shaders/glsl/testFolder/aniTex.glsl\n    float uOffset = float(col) / float(numCols);\r \n#line 10:shaders/glsl/testFolder/aniTex.glsl\n    float vOffset = float(row) / float(numRows);\r \n#line 11:shaders/glsl/testFolder/aniTex.glsl\n  \r \n#line 12:shaders/glsl/testFolder/aniTex.glsl\n    _ANI_TEX_UV = vec2(\r \n#line 13:shaders/glsl/testFolder/aniTex.glsl\n        uOffset + (uv.x + 0.5) / numCols, \r \n#line 14:shaders/glsl/testFolder/aniTex.glsl\n        1.0 - vOffset - (uv.y + 0.5) / numRows  \r \n#line 15:shaders/glsl/testFolder/aniTex.glsl\n    );\r \n#line 16:shaders/glsl/testFolder/aniTex.glsl\n  } \n\n#line 0:shaders/glsl/basic-vert.glsl\n  #include \"./testFolder/aniTex.glsl\"\r \n#line 1:shaders/glsl/basic-vert.glsl\n  \r \n#line 2:shaders/glsl/basic-vert.glsl\n  \r \n#line 3:shaders/glsl/basic-vert.glsl\n  attribute vec3 gridIndex;\r \n#line 4:shaders/glsl/basic-vert.glsl\n  attribute vec2 uv;\r \n#line 5:shaders/glsl/basic-vert.glsl\n  \r \n#line 6:shaders/glsl/basic-vert.glsl\n  uniform mat4 uPMatrix;\r \n#line 7:shaders/glsl/basic-vert.glsl\n  uniform mat4 uVMatrix;\r \n#line 8:shaders/glsl/basic-vert.glsl\n  uniform mat4 uMMatrix;\r \n#line 9:shaders/glsl/basic-vert.glsl\n  \r \n#line 10:shaders/glsl/basic-vert.glsl\n  varying vec2 vTexCoord;\r \n#line 11:shaders/glsl/basic-vert.glsl\n  \r \n#line 12:shaders/glsl/basic-vert.glsl\n  void main(void) {\r \n#line 13:shaders/glsl/basic-vert.glsl\n  \r \n#line 14:shaders/glsl/basic-vert.glsl\n      vec3 origin = gridIndex;\r \n#line 15:shaders/glsl/basic-vert.glsl\n      vec3 offset = vec3(uv.x, uv.y, 0);\r \n#line 16:shaders/glsl/basic-vert.glsl\n      vec3 position = origin + offset;\r \n#line 17:shaders/glsl/basic-vert.glsl\n  \r \n#line 18:shaders/glsl/basic-vert.glsl\n      gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(position, 1.0);\r \n#line 19:shaders/glsl/basic-vert.glsl\n      vTexCoord = uv;\r \n#line 20:shaders/glsl/basic-vert.glsl\n  }\r \n#line 21:shaders/glsl/basic-vert.glsl\n   \n","params":{"gridIndex":{"type":"vec3","value":null},"uv":{"type":"vec2","value":null}}};

export { basicVert };
